## 散列表

### 哈希函数

首先来一个最简单的伪哈希函数，定义 `hash(x) = x`。即 `hash(1) = 1`，`hash(10000) = 10000`，将经过哈希函数计算过后的值当做数组的索引值，就可以达到 O(1) 级别的查找效率。比如我想找键为 100 对应的值，直接找 `arr[99]` 即可。

但这样简单随意的哈希函数无法在实际中应用，为什么呢？因为数据可能是无限大的，但我们却没有无限大的空间来存储。比如我要存储 1000000000000，难道要建立一个长度为 1000000000000 的数组？这也太过浪费了点。所以实际应用中的哈希函数是一种**有损**的压缩算法，能将任意长度的数据映射为**固定长度**的数据。

我们可以再定义一个简单地哈希函数：**对于任意输入的数据，我们都去数据中的后两位作为哈希值。不足两位的补 0。**采用这个版本的哈希函数来计算哈希值：`hash(100) = 00`，`hash(189005) = 05`。这样以来，就不会出现浪费了过多的数组空间的问题了。

但这是一种有损的压缩算法，为什么说是有损呢，因为它会产生冲突的情况。比如 `hash(101) = 01`，`hash(10001) = 01`，出现了不同数据拥有相同哈希值的情况。这种情况被称为**哈希冲突**。

### 哈希冲突

主要有以下几种处理冲突的方法：

#### 开放地址检测

**线性探测法**

从出现冲突的位置开始向后循环遍历 hash 表，直到找到表中的下一个空槽，并将该元素放入该槽中（会导致相同 hash 值的元素挨在一起和其他 hash 值对应的槽被占用）。

查找元素时，首先去找散列值所指向的槽，如果没有找到匹配，则继续从该槽遍历 hash 表，直到：

- 找到相应的元素
- 或者找到一个空槽，指示查找的元素不存在，（所以不能随便删除元素）
- 或者整个 hash 表遍历完毕（指示该元素不存在并且 hash 表是满的） 

线性探测法的探测序列为：hi=(h(key)+i) ％ m（m 为散列表长度）# 待处理

开放地址检测存在一些问题：

- 难以删除（删除后需要打上删除标记）
- 堆聚现象：存入哈希表的记录在表中连成一片，连续的越长就越可能冲突，越冲突连续的序列就越长……

**线性补偿探测法**

将线性探测的步长从 1 改为 Q ，即将上述算法中的 hash ＝ (hash ＋ 1) % m 改为：hash ＝ (hash ＋ Q) % m = hash % m + Q % m，而且要求 Q 与 m 是互质的，以便能探测到哈希表中的所有单元。	

**伪随机探测**

将线性探测的步长从常数改为随机数，即令： hash ＝ (hash ＋ RN) % m ，其中 RN 是一个随机数。

#### 拉链法

出现冲突时将散列值相同的元素链接在同一个单链表中。若选定的散列表长度为 m，则可将散列表定义为一个由 m 个头指针组成的指针数 组 T[0..m-1]。凡是散列地址为 i 的结点，均插入到以 T[i]为头指针的单链表中。T 中各分量的初值均应为空指针。

**缺点**

指针需要额外的空间，故当结点规模较小时，开放定址法较为节省空间，而若将节省的指针空间用来扩大散列表的规模，可使装填因子变小，这又减少了开放定址法中的冲突，从而提高平均查找速度。 

#### 再散列

使用第二个、第三个散列函数重新计算散列值，直到不再冲突为止。缺点是比较浪费计算时间。