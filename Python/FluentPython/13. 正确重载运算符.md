## 重载运算符

#### 1. Python 运算符重载的限制

运算符重载可能会被滥用，甚至已经被很多人滥用，在编程圈子里运算符重载有着不好的名声。导致的结果是，一些编程语言如 Java 就不支持运算符重载。Python 支持重载运算符，但施加了一些限制：

- 不能重载内置类型 ( 如 str、list) 的运算符
- 不能新建运算符，只能重载现有的
- is、and、or 和 not 运算符不能重载

#### 2. 重载运算符用到的特殊方法

详见《Python 特殊方法》一节

#### 3. 中缀运算符调用顺序

我们现在要执行 a + b，解析顺序如下：

- 如果 a 有 `__add__` 方法，而且返回值不是 NotImplemented，调用 `a.__add__(b)`，返回结果
- 检查 b 有没有 `__radd__` 方法，如果有且没有返回 NotImplemented，调用 `b.__radd__(a)`，返回结果
- 抛出 TypeError，并在错误信息中指明操作数类型不支持

注意，通常情况下，`__radd__` 方法直接调用合适的运算符运算即可。

#### 4. 比较运算符的行为

Python 对比较运算符 (==、!=、>、<、<=、>=) 的处理和和其他运算符类似，但两个方面有些不同：

- 正向和反向调用相同的方法，只是把参数互换。如正向 `__gt__` 方法，调用反向的 `__lt__` 方法
- 对于 == 和 != 来说，如果反向调用失败，Python 会比较两个对象的 id，而不抛出 TypeError

#### 5. 比较运算符的调用顺序

我们现在要比较 a == b:

- 调用 `a.__eq__(b)`，若相等 / 不等，返回结果
- 如果是 NotImplemented，尝试调用 `b.__eq__(a)`
- 如果仍然返回 NotImplemented，Python 比较两个对象的 id，做最后一搏

#### 6. 注意事项

- 实现一元运算符和中缀运算符一定不能修改操作数，而要返回一个新对象。只有增量运算符可能修改第一个操作数。
- Python3 中，`__ne__` 的结果是对 `__eq__` 的取反，一般而言我们无需实现 `__ne__` 方法，从 object 那继承来的足够使用了
- 对于不可变类型，一定不能实现就地特殊方法 ( 如 `__radd__`)



