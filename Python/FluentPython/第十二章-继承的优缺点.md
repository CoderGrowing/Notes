## 继承的优缺点

#### 1. Python内置类型的不一致行为

对于用户定义的类而言，子类重写的方法会覆盖父类中的同名方法。但对于这个问题Python内置类型却出现了不一样的行为。

```python
class MyDict(dict):
    def __setitem__(self, key, value):
        super().__setitem__(key, [value] * 2)
        
d = MyDict(one=1)
d    # {'one': 1}    并不是预期的{'one': [1,1]}
d['two'] = 2
d    # {'one': 1, 'two': [2, 2]}    # 直接设置值调用了我们重写的__setitem__方法
```

当我们实例化内置类型的子类时本应该调用我们自己重写的方法，但Python并没有这么做。也就是说，内置类型不会调用用户定义的类覆盖的特殊方法。

出现这一现象的原因是出于性能的考虑。内置的类型在Python底层使用C语言实现，它几乎对所有Python代码都有影响，因此速度必须要快。出于这方面的考虑，CPython故意让内置类型行为不当，不去调用子类覆盖方法。

但为了方便用户扩展， Python还内置了`UserDict`、`UserList`、`UserString`等供用户扩展的方法。如果需要扩展内置类型的话，需要从这些类型继承。

#### 2. 多重继承的方法解析顺序

```python
class A:
    def p(self):
        print('ap')
class B:
    def p(self):
        print('bp')
class C(A, B):
    pass
c = C()
c.p()   # 该输出什么？
```

多重继承必须处理如上面例子中命名冲突的问题，即为子类选择合适的调用方法。在Python中，上述例子会输出"ap"，即调用了A的方法。决定调用哪个父类方法是按照一定顺序进行的，这个顺序叫做"方法解析顺序(Method Resolution Order, MRO)"。Python的类都有一个`__mro__`属性，该属性就是当前类的方法解析顺序。我们列出C的`__mro__`属性：

```python
C.__mro__     # (__main__.C, __main__.A, __main__.B, object)
```

 当调用C实例的方法时就按照这个顺序去查找：先看C有没有这个方法，有的话调用；没有的话去A中查找，最后在B中查找。在类中使用`super()`方法时同样是按照这个顺序来执行。

#### 3. 何时使用多重继承

我还记得当初看《笨办法学Python》时作者在讲继承时说：多重继承要尽可能的避免！

1. **把接口继承和实现继承区分开**

   继承可能是为了：

   - 继承接口，实现"是什么"关系
   - 继承实现，重用代码

   如果是为了重用代码，通常可以换用组合和委托模式。

2. **使用抽象基类显示表示接口**

   如果类的作用是为了定义接口，应该明确的声明为抽象基类。

   `class interface(abc.ABC)`(Python3.4以上)

   `class interface(object):`

   ​	`__metaclass__ = abc.ABCMeta`(Python2)

3. **通过混入重用代码**

   如果一个类是为了多个不相关子类提供方法实现，但不体现"是什么" 关系，应该把那个类定义为"混入类(mixin class)"。需要注意：

   - 混入类不能实例化
   - 具体类不能只继承混入类
   - 在名称中明确指明是混入类，加入Mixin后缀，如`class ExampleMixin`
   - 抽象基类可以作为混入，但反过来不成立

4. **不要子类化多个具体类**

   继承的类可以没有，或者只有一个，但一定不能同时继承多个具体父类

5. **聚合类**

   如果有多个混入类/抽象基类都需要继承，可以为用户提供一个聚合类，把它们结合起来，这样用户只需要继承这一个聚合类即可。

   ```python
   class Widget(BaseWidget, Pack, Place, Grid):
       """doc here"""
   ```

   ​