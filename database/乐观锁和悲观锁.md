# 乐观锁和悲观锁

### 悲观锁

顾名思义悲观锁是基于一种悲观的态度类来防止一切数据冲突，它是以一种预防的姿态在修改数据之前把数据锁住然后再对数据进行读写，在它释放锁之前任何人都不能对其数据进行操作，直到前面一个人把锁释放后下一个人数据加锁才可对数据进行加锁，然后才可以对数据进行操作，一般数据库本身锁的机制都是基于悲观锁的机制实现的 ;

**特点**：可以完全保证数据的独占性和正确性，但因其加锁释放锁的过程会造成消耗，所以性能不高。

**手动加悲观锁**：

读锁： `LOCK tables test_db  read`

写锁：`LOCK tables test_db  WRITE`

释放锁 `UNLOCK TABLES;`

### 乐观锁

乐观锁是对于数据冲突保持一种乐观态度，操作数据时不会对数据锁定（这使得多个任务可以并行的对数据进行操作），只有到数据提交的时候才通过一种机制来验证数据是否存在冲突 ( 一般实现方式是通过加版本号然后进行比对比对的方式实现 )。

**特点**：乐观锁是一种并发类型的锁，本身不对数据进行加锁通过业务实现锁的功能，不对数据进行加锁就意味着允许多个请求同时访问数据，这种方式**大大的提高了并发数据请求的性能**。

如下图所示，A 的提交不会成功：

![](http://oqag5mdvp.bkt.clouddn.com/201804121400_218.jpg)

如果系统被并发访问的概率很低，或者冲突发生后的后果不太严重（所谓后果应该指被检测到冲突的提交会失败，必须重来一次），可以使用乐观锁，否则使用悲观锁。  

### 适用场景

悲观锁：比较适合写入操作比较频繁的场景，如果出现大量的读取操作，每次读取的时候都会进行加锁，这样会增加大量的锁的开销，降低了系统的吞吐量。

乐观锁：比较适合读取操作比较频繁的场景【，如果出现大量的写入操作，数据发生冲突的可能性就会增大，为了保证数据的一致性，应用层需要不断的重新获取数据，这样会增加大量的查询操作，降低了系统的吞吐量。

1. 响应速度：如果需要非常高的响应速度，建议采用乐观锁方案，成功就执行，不成功就失败，不需要等待其他并发去释放锁

2. 冲突频率：如果冲突频率非常高，建议采用悲观锁，保证成功率，如果冲突频率大，乐观锁会需要多次重试才能成功，代价比较大

3. 重试代价：如果重试代价大，建议采用悲观锁