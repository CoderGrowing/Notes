# 排序

### 1. 选择排序

#### 思路

首先找到数组中最小的那个元素，将它和数组中第一个元素交换位置（如果本来就是第一个元素就和自己交换）。然后再在剩余的元素中找到最小的，和第二个元素交换位置……直至排序完成。

#### 实现

```java
public class Selection {
    public static void sort(Comparable[] a) {
        int N = a.length;
        for (int i = 0; i < N; i++) {
            int min = i;           // 最小元素索引
            for (int j = i + 1; j < N; j++)
                if(BaseSort.less(a[j], a[min]))      // 如果a[j] < a[min]，交换位置
                    min = j;
            BaseSort.exchange(a, i, min);
        }
    }
}
```

#### 性能

对于长度为N的数组，选择排序需要大约N^2^次比较和N次交换。

**证明**

0-N-1的任意i都会进行一次交换和N-1-i次比较，因此交换次数为N次（外循环每循环一次都交换一次，即使有序也需要与自身交换）。

比较次数为(N-1) + (N-2) +...+2+1 = N(N-1)/ 2，约为N^2^/2次比较。

#### 特点

运行时间与输入无关，即使有序性能也不会提升。

数据的移动是最少的，只需要N次交换，与数组大小成线性关系。

#### 2. 插入排序

#### 思路

将每一个元素插入到其他已经有序的元素中的适当位置处。如此，当前索引左边的元素都是已经有序的，只是最终位置还不确定。

#### 实现

```java
public class Insertion {
    public static void sort(Comparable[] a) {
        int N = a.length;
        for (int i = 1; i < N; i++) {
            for (int j = i; j > 0 && BaseSort.less(a[j], a[j-1]); j--)
                BaseSort.exchange(a, j, j-1);
        }
    }
}
```

