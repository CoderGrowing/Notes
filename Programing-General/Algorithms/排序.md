# 排序

### 1. 选择排序

#### 思路

首先找到数组中最小的那个元素，将它和数组中第一个元素交换位置（如果本来就是第一个元素就和自己交换）。然后再在剩余的元素中找到最小的，和第二个元素交换位置……直至排序完成。

#### 实现

```java
public class Selection {
    public static void sort(Comparable[] a) {
        int N = a.length;
        for (int i = 0; i < N; i++) {
            int min = i;           // 最小元素索引
            for (int j = i + 1; j < N; j++)
                if(BaseSort.less(a[j], a[min]))      // 如果a[j] < a[min]，交换位置
                    min = j;
            BaseSort.exchange(a, i, min);
        }
    }
}
```

#### 性能

对于长度为N的数组，选择排序需要大约N^2^次比较和N次交换。

**证明**

0-N-1的任意i都会进行一次交换和N-1-i次比较，因此交换次数为N次（外循环每循环一次都交换一次，即使有序也需要与自身交换）。

比较次数为(N-1) + (N-2) +...+2+1 = N(N-1)/ 2，约为N^2^/2次比较。

#### 特点

运行时间与输入无关，即使有序性能也不会提升。

数据的移动是最少的，只需要N次交换，与数组大小成线性关系。

### 2. 插入排序

#### 思路

从第二个元素开始，将其当做键值（key）。将它与它前面的所有元素进行比较，如果它小于前面的某个元素，则进行交换。如此，当前索引左边的元素都是已经有序的，只是最终位置还不确定。

#### 实现

```java
public class Insertion {
    public static void sort(Comparable[] a) {
        int N = a.length;
        for (int i = 1; i < N; i++) {  				// 从第二个元素开始当做键值遍历数组
            for (int j = i; j > 0; j--)  // 如果键值小于前面元素，交换
                if (BaseSort.less(a[j], a[j-1]))
                	BaseSort.exchange(a, j, j-1);
        }
    }
}
```

#### 性能

对于随机排列的长度为N且主键不重复的数组，平均情况下插入排序需要大约N^2^/4次比较以及约N^2^/4次交换。最坏情况需要约N^2^/2次比较和N^2^/2次交换。最好情况需要N-1次比较和0次交换。

**证明**

最好情况：数组有序，只需遍历一遍比较即可，比较次数为N-1，交换次数为0

最差情况：数组是倒序的，比较次数为1+2+....+N-1约为N^2^/2，每次比较都需要交换，交换次数同样为N^2^/2

#### 特点

插入排序依赖输入状态，当数组已经部分有序甚至绝大部分有序的时候有良好的表现。

### 3. 希尔排序

#### 思路

希尔排序的思想是使数组中任意间隔为h的元素都是有序的，这样的数组称为h有序数组。

#### 实现

```java
public class Shell {
    public static void sort(Comparable[] a) {
        int N = a.length;
        int h = 1;
        while (h < N/3)
            h = 3*h + 1;      // 1, 4, 13, 40, ...初始间隔
        while (h >= 1) {
            for (int i = h; i < N; i++) {
                for (int j = i; j >= h && BaseSort.less(a[j], a[j-h]); j -= h)
                    BaseSort.exchange(a, j, j-h);
            }
            h = h / 3;
        }
    }
}
```

初始化h为3*h+1为数组选择一个增幅，加1保证最后的排序使数组变为1有序数组。

### 4. 归并排序

####  思路

要将一个数组排序，可以先（递归的）将它分成两半分别排序，再将结果归并起来。实现归并排序的主要步骤就是合并两个子数组的过程。合并时，首先将两个子数组复制到一个大数组内，然后维护两个索引值，分别指向两个子数组的起始位置。由于两个数组已经是有序的，所以最小的元素一定是两个数组其中一个的首元素。比较两个元素，将小的那个移动到未合并前的子数组中。移动后的索引向后移动，再继续进行比较。

初始状态：将A和E进行比较，发现A较小：

![](http://oqag5mdvp.bkt.clouddn.com/201804042056_615.jpg)

​	将A复制过去，j++，再将C和E进行比较。

![](http://oqag5mdvp.bkt.clouddn.com/201804042058_963.jpg)

#### 实现

```java
public class Merge {
    private static Comparable[] aux;     // 归并需要而辅助数组

    public static void sort(Comparable[] a) {
        aux = new Comparable[a.length];
        sort(a, 0, a.length - 1);
    }

    private static void sort(Comparable[] a, int lo, int hi) {
        if (hi <= lo) return;
        int mid = lo + (hi - lo) / 2;
        sort(a, lo, mid);
        sort(a, mid+1, hi);
        merge(a, lo, mid, hi);
    }

    public static void merge(Comparable[] a, int lo, int mid, int hi) {
        int i = lo, j = mid + 1;

        for (int k = 0; k <= hi; k++) {
            aux[k] = a[k];      // 复制数组
        }

        for (int k = lo; k <= hi; k++) {
            if (i > mid)
                a[k] = aux[j++];        // 左边归并完成，进行mid--hi的归并
            else if (j > hi)
                a[k] = aux[i++];		// 右边归并完成，进行lo--mid的归并
            else if (BaseSort.less(aux[j], aux[i]))
                a[k] = aux[j++];		// 右边的当前元素比左边当前元素小，取右边当前元素复制过去
            else
                a[k] = aux[i++];		// 右边当前元素比左边当前元素大，取左边元素复制过去
        }
    }
}
```

调用merge时lo--mid以及mid--hi已经是两个有序的数组。进行归并时，只需要挨个比较左右边元素大小即可。

```java

```

### 5. 快速排序

快速排序可能是应用最为广泛的排序算法。它实现简单、不依赖输入数据。

#### 思路

快速排序也是一种分治的排序算法。先将一个数组分为两个子数组，再将两部分独立的排序。快速排序的关键在于对数组的切分。切分过程使数组满足三个条件：

- 对于某个j，a[j]已经排定
- a[lo]到a[j-1]中的所有元素都不大于a[j]
- a[j+1]到a[hi]中的所有元素都不小于a[j]

通过递归调用这个过程使得排序完成。

#### 实现

```java
package sort;

import edu.princeton.cs.algs4.StdRandom;

public class Quick {
    public static void sort(Comparable[] a) {
        StdRandom.shuffle(a);       // 打乱，不依赖输入
        sort(a, 0, a.length-1);
    }

    private static void sort(Comparable[] a, int lo, int hi) {
        if (hi < lo)    return;
        int j = partition(a, lo, hi);       // j为切分点
        sort(a, lo, j-1);
        sort(a, j+1, hi);
    }

    private static int partition(Comparable[] a, int lo, int hi) {
        int i = lo, j = hi+1;    // 左右扫描指针
        Comparable v = a[lo];

        while (true) {
            // 从左向右扫描，找到一个比v大的元素
            while (BaseSort.less(a[++i], v))
                if (i == hi)
                    break;
            // 从右向左扫描，找出一个比v小的元素
            while (BaseSort.less(v, a[--j]))
                if (j == lo)
                    break;
            // 指针相遇
            if (i >= j)
                break;
            BaseSort.exchange(a, i, j);
        }
        BaseSort.exchange(a, lo, j);
        // 返回切分点
        return j;
    }
}
```

#### 性能

对于长度为N的无重复数组排序，快速排序平均需要约2NlnN次比较，以及1/6次的交换

