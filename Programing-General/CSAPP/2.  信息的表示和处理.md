# 2. 信息的表示和处理

一开始我对这章的名字有些不理解：明明讲的都是数据的表示和处理，为什么章节名要叫信息的表示和处理呢？细细思索一番才觉恍然，原因正是作者在第一章就说明了的一件事：**信息就是位加上下文**。

在计算机系统中，无论是程序、用户数据乃至磁盘文件，都是由一个个的二进制位来表示的 -- 对，计算机里的无论什么东西，都只有 0 和 1。那计算机如何区分不同的对象呢？靠的就是上下文信息。

正好最近在读王爽的《汇编语言》，就拿 8086CPU 来举例。对于 8086 来说，区分数据和指令的途径就是寄存器的值。CS:IP 寄存器指向的数据被当做指令来执行；DS:( 偏移地址 ) 指向的数据就当做普通数据来对待。

无论是数据还是可执行的指令，在计算机内部并无任何区别，区别只是在于 CPU 对待它们的方式不同而已。所以本章看似再讲数据的处理，其实所有信息的处理方式都不外乎于此。

## 2.1 信息存储

### 2.1.1 位、字长和字节

位、字长和字节的概念不再赘述，这里探讨一下为何提出这些概念。

一个 0 或 1 就是一位 (bit)，是计算机能够表示的最小信息。所以位的概念至关重要。那为何要把 8 位称为一个字节，提出字节的概念呢？固然是在表示大量数据时有了更方便的表述，但字节的概念还有更重要的意义：**大多数计算机使用 8 位的块作为最小的可寻址的内存单元**。

字节用来寻址，那字长呢？字长用来指明指针数据的标称大小 (nominal size)，一个字长为 w 位的机器，虚拟地址的范围为 0~2^W^-1，程序最多访问 2^W^ 个字节。现在明白为什么 4GB 内存以上的电脑要装 64 位 Windows 了吧？

### 2.1.2 32 位和 64 位程序的区别

那 32 位 Windows 和 64 位 Windows，或者是说 32 位程序和 64 位程序的区别是什么？

我们知道，大多数的 64 位机器可以运行 32 位机器编译的程序，这是一种向后兼容。如果我们用一下命令编译一个程序：

```shell
gcc -m32 program.c
```

得到的程序就是 32 位的程序，可以在 32 位或者 64 位机器上运行。如果我们编译时用的指令是：

```shell
gcc -m64 program.c
```

那就只能在 64 位机器上运行。因此，32 位和 64 位程序的区别在于该程序是如何编译的。

拿 C 语言来说，编译方式的不同导致了各数据类型所分配的字节数可能不同。下面是一个简单地对照表：

| 有符号           | 无符号            | 32 位  | 64 位  |
| ------------- | -------------- | ---- | ---- |
| [signed] char | unsigned char  | 1    | 1    |
| short         | unsigned short | 2    | 2    |
| int           | unsigned       | 4    | 4    |
| long          | unsigned long  | 4    | 8    |
| int32_t       | uint32_t       | 4    | 4    |
| int64_t       | uint64_t       | 8    | 8    |
| char *        |                | 4    | 8    |
| float         |                | 4    | 4    |
| double        |                | 8    | 8    |

注意 long 和 char *类型在不同位数机器上的不同表现。

### 2.1.3 大端和小端

大端和小端的名字来源于《格列佛游记》。《格列佛游记》记载了 Lilliput 和 Blefuscu 两个国家为了争论吃鸡蛋应该从大头打破还是从小头打破而战争不断的故事。

而对大端和小端选择的争辩也正如鸡蛋从哪头打破更好的争论一样，毫无意义，他们只是两种通用的规则罢了。对于一个ω位的整数，其位表示为 ![公式名](http://latex.codecogs.com/png.latex?[x_{w-1}, x_{w-2}..., x_0]) 其中 ![x_w-1](http://latex.codecogs.com/png.latex?x_{w-1}) 是最高有效位，而 ![公式名](http://latex.codecogs.com/png.latex?x_0) 是最低有效位。假设ω是 8 的倍数，这些位可以被分组为字节，最高有效位字节为[![公式名](http://latex.codecogs.com/png.latex?[x_{w-1}, x_{w-2}, ..., x_{w-8}]) 最低有效位字节为：![公式名](http://latex.codecogs.com/png.latex?[x_7, x_6, ..., x_0])。某些机器按照从最低字节到最高字节的顺序来存储，称为小端法 (little endian)，有些机器按照最高字节到最低字节的顺序来存储，称为大端法 (big endian)。

现在很多新的处理器都支持双端法 (bi-endian)，即可以自由配置为大端或者小端机器。但受操作系统所限，一旦选定了操作系统，字节顺序也就固定下来了。一般而言现在的 Linux 和 Windows 都是采用的小端法。

**最高有效字节在前叫做大端，反之则是小端。**

### 2.1.4 C 语言中的移位运算

C 语言提供了 << 和 >> 两个运算符来支持移位运算。

**左移**：表达式 x<<k 向左移动 k 位，即丢弃最高的 k 位，并在右端补 k 个 0。

**右移**：右移运算相较于左移略微麻烦，机器支持两种形式的右移：逻辑右移和算术右移。对于运算 x>>k，**逻辑右移在左端补 k 个 0**，**算术右移在左端补 k 个最高有效位的值**。下面通过例子说明，设 x 为 10010101

| 操作           | 值          |
| ------------ | ---------- |
| x << 4       | 0101*0000* |
| x >> 4( 逻辑右移 ) | *0000*1001 |
| x >> 4( 算术右移 ) | *1111*1001 |

斜体部分是填充的值。

C 语言并没有规定对于有符号数使用哪种右移方式，但几乎所有的机器和编译器都会使用**算术右移**。而对于无符号数，右移一定是逻辑右移。

## 2.2 整数的表示

计算机中对数字的表示有三种重要的方法。一种是补码 (two's complement) 形式，一种是无符号的形式，另一种就是浮点数形式。前两种方式都用来表示较小的整数。

### 2.2.1 无符号数编码

无符号编码就是一个二进制数字的位表示形式， 按照不同位数的权值将其相加即是数的值。

### 2.2.2 补码和原码编码

但无符号编码只能表示非负数，而我们经常会用到负数。表示负数的最常用的编码形式是原码和补码形式。

原码编码的概念较为简单：正用 0 表示，负用 1 表示。即原码的最高有效位为符号位，符号位为 0 表示该数为正数，符号位为 1 表示是负数。其他位按照权重相加即为表示的数值。

![](http://oqag5mdvp.bkt.clouddn.com/201803191704_426.jpg)

原码的问题在于 0 的表示不唯一（出现了 +0 和 -0）、加减运算不统一等。于是人们又引进了补码的定义。

补码的最高有效位是符号位，被解释为 " 负权 "。正数的最高有效位为 0，所以正数的原码和补码一致。

例：

补码 0000 表示 0；

补码 1011 表示：-1 * 2^3^ + 0 * 2^2^ + 1 * 2^1^  + 1 * 2^0^ = -5。

对于任意的 $$w$$ 位补码表示的二进制数，我们有：

最大值 TMax = [01111 …… 11] = 2^w-1^ - 1

最小值 TMin = [10000 …… 00] = - 2^w-1^

注意范围并不是对称的。

**补码和模运算**

![](http://oqag5mdvp.bkt.clouddn.com/201803191724_5.jpg)

### 2.2.3 类型转换

在进行有符号和无符号数之间的互相转换时：

- 强制类型转换的结果保持位值不变，只是改变了解释这些位的方式

例：

```c
short int v = -12345;
unsigned shrot uv = (unsigned short) v;
printf("v = %d, uv = u%\n", v, uv);

#v = -12345; uv = 53191;
```

![](http://oqag5mdvp.bkt.clouddn.com/201803101846_886.jpg)

- **如果一个表达式既包含有符号数也包含无符号数，那么会被隐式转换成无符号数进行比较**

如果不注意 C 语言的这个行为，可能会得到意想不到的结果。例如，判断下面这个表达式的值：

-1 < 0U。结果是 false(0)。两个数都被强制转换为无符号数，-1 的无符号表示为 11111111（int 型）。

### 2.2.4 扩展与截断

**扩展**

- 零扩展：无符号数要扩展时直接在位表示开头加 0 即可，这种运算被称为零扩展（zero extension）
- 符号扩展：补码想要扩展时，可以在位表示开头补任意个最高有效位的值，这种扩展被称为符号扩展（sign extension）
  原表示：[x~w-1~, x~w-2~, …… , x~0~]， 扩展后表示：[x~w-1~, x~w-1~，x~w-1~，…… ,x~w-2~, …… , x~0~]

**截断**

- 无符号数：截断 k 位后，x' = x mod 2^k^
- 有符号数：截断 k 位，x' = U2T~k~(x mod 2^k^)

## 2.3 整数运算

### 2.3.1 无符号加法

两个非负数 x 和 y，满足 0 <= x, y <= 2^w^，那么两数之和范围就为 0<= x+y <= 2^w+1^。即可能产生溢出。对此 C 语言的处理方式是将两数之和直接截断位 w 位。当没有产生溢出时，它的结果与我们预期的一致。当溢出产生时，结果为：x + y - 2^w^。

**无符号数求反**

对于 0 <= x < 2^w^ 的 x，有：-x = 0(x = 0)；-x = 2^w^ - x（x>0）。

### 2.3.2 补码加法

对于 -2^w-1^ <= x, y <= -2^w-1^-1，x + y 有：

x + y - 2^w^（正溢出），x + y（正常），x + y + 2^w-1^（负溢出）。

### 2.3.3 无符号乘法

将一个无符号数截断位 w 位等价于计算该值模 2^w^，即：

对于 0 <= x, y <= UMax~w~ 的 x 和 y 有：x * y = (x * y) mod 2^w^。

### 2.3.4 补码乘法

补码乘法同无符号乘法，得到结果后截断 w 位，再按照补码解释所得值即可。即补码乘法和无符号乘法拥有位级等价性。

### 2.3.5 乘 / 除以常数

在大多数机器上计算乘法和除法需要消耗较多的时间，乘法需要 10 个以上的时钟周期，除法更是需要 30 个以上时钟周期。而计算加减法、移位运算却只需要 1 个时钟周期。为了优化程序性能，很多编译器会使用加减法和移位运算来代替乘法和除法的计算。

#### 乘法

一个数乘以 2^w^ 等于该数左移 w 位。例如 x * 16 = x << 4。

利用这个原理我们可以将任何整数乘法换为移位运算：

形式 A：(x<<n) + (x<<n-1)+ …… +(x<<m)

形式 B：(x<<n+1) - (x<<m)

#### 除法

除法总应该向零舍入。对于 3.14，舍入后为 3；对于 -3.14，舍入后为 -3。即对于整数，它向下舍入，对于负数，它向上舍入。 

对于无符号除法，直接使用逻辑右移即可得到理想的结果。

对于补码除法，当 x 大于 0 时，右移效果等同于逻辑右移。但当 x 小于 0 时，移位会导致向下舍入，需要利用偏置值来修正结果：(x+(1<<k)-1)>>k 产生数值 x/2^k^。

## 2.3 浮点数

计算机内表示小数的方式有两种：定点数和浮点数。所谓的定点数就是小数位是固定的，比如我们约定一种 32 位定点小数，小数点在第五位数之后，则它能表示的最大值为：11111.111111111111111111111111111，才 32 多点。而且当我们表示很小的数值时，大多数位都是 0，精度比较差。

为了解决这些问题，人们提出了浮点数的概念。所谓的浮点数就是小数位并不是固定的，它可以表示较高精度的很小的数（趋近于 0）或者很大的数值。浮点数类似于科学计数法，例如 1.1 * 10^6^，使用一个小数来确定基数，一个整数来确定指数。这个基数在浮点数中叫尾数，指数叫做阶码。

### 2.3.2 IEEE 浮点数表示

IEEE 标准用 V = (-1)^s^ * M * 2^E^ 来表示一个数：

- 符号（sign）：s 决定了这个数是正数还是负数
- 尾数（significand）：M 是一个二进制小数
- 阶码（exponent）：E 的作用是对浮点数加权，权重为 2 的 E 次方幂（可能是负数）

这三个值的分别编码：

- s：单独的符号位，直接编码
- E：k 位的阶码字段 exp = e~k-1~...e~1~e~0~ 编码阶码 E
- M：n 位的小数字段 frac = f~n-1~...f~1~f~0~ 编码尾数 M

对于单精度的浮点数（32 位），s、exp 和 frac 字段分别为 1 位、8 位和 23 位。对于双精度的浮点数（64 位），分别为 1 位、11 位和 52 位。如下图所示：

![](http://oqag5mdvp.bkt.clouddn.com/201803191625_365.jpg)

**规格化**

当阶码 exp 的值非全 0（0）或者全 1（单精度 255，双精度 2047）时被称为是规格化的值。此时阶码字段被解释为偏置形式（biased）表示的有符号整数，阶码的值为 E = exp - Bias。这种加上一个偏置常数的表示被称为**移码表示**。通常 Bias 取 2^n-1^ 或者 2^n-1^-1。

- exp：无符号数，位表示为 e~k-1~...e~1~e~0~
- Bias：值为 2^k − 1^ − 1 的偏移量，其中 k 是 exp 编码的位数，也就是说：
  - 单精度：偏移量为 127（即 exp 范围为 1~254, 阶码 E 的范围为 -126~127）
  - 双精度：偏移量为 1023（exp 范围为 1~2046, 阶码 E 的范围为 -1022~1023）

为什么要采用移码来表示阶码呢？主要是为了保证阶码的值均为正值。在进行浮点数运算时常常要比较阶码的大小，如 -1 和 7 比较大小，采用补码形式的话，-1 表示为 1111，7 表示为 0111，直观上 -1 是大于 7 的。为了简化这个运算，我们都采用移码表示，将其加上一个偏置值保证阶码均大于 0。

而对于尾数 frac 字段用来描述小数值 f，f 是大于 0 小于 1 的。尾数被定义为 M = 1+ f，即总是以 1 开头的。如此，这个 1 我们可以不表示，从而获得了一个额外的精度，用 23 位表示了 24 位的精度。

**非规格化**

当阶码全为 0 时，表示的数是非规格化的数。此时阶码值 E = 1 - Bias，M = f。

非规格化值

**特殊值**

最后一类数值是阶码全为 1 时出现的。当小数域全为 0 时，得到的值表示无穷；当 s=0 时表示的是正无穷，反之则是负无穷。当小数域非零时，值被称为 NaN，即“ Not a Number"，不是一个数。

**例子**

![](http://oqag5mdvp.bkt.clouddn.com/201803200921_445.jpg)

### 2.3.3 舍入

浮点数的表示方法限制了它的精度，所以浮点运算只能近似的表示实数运算。因此，对于值 x 我们必须有一定的方法决定如何舍入（rounding）。下表列出了常见的四种舍入方式：

| 方式       | 1.40 | 1.60 | 1.50 | 2.50 | -1.50 |
| ---------- | ---- | ---- | ---- | ---- | ----- |
| 向偶数舍入 | 1    | 2    | 2    | 2    | -2    |
| 向零舍入   | 1    | 1    | 1    | 2    | -1    |
| 向下舍入   | 1    | 1    | 1    | 2    | -2    |
| 向上舍入   | 2    | 2    | 2    | 3    | -1    |

值得注意的是向偶数舍入的情况。向偶数舍入是向最近的值舍入，也就是“四舍五入”。它唯一规定的是这个“五入”该怎么入。它采取的方法就是使得结果的最低有效数字是偶数。

### 2.3.4 浮点运算

- 浮点加法不具有结合性，即 a + b + c 可能不等于 a + (b + c)
- 除零并不会产生异常。正数除零得到正无穷，负数除零会得到负无穷
- C 语言中的类型转换：
  - int -> float，不会溢出，但可能被舍入
  - int/float -> double，精确保留
  - double -> float，可能会溢出或者舍入
  - float/double -> int，值会向零舍入

## 补充内容

1. 考虑下面的代码：

   ```c
   int x, y;
   int64_t result = x * y;
   int64_t result = (int64_t) x*y;
   ```

   对于第一种情况，result 的值是 x*y 的结果截断为 32 位的值（可能会溢出），而后符号扩展到 64 位。

   而第二种则是利用强制类型转换，保证了运算没有溢出。


