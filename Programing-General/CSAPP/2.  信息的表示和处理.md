# 2. 信息的表示和处理

一开始我对这章的名字有些不理解：明明讲的都是数据的表示和处理，为什么章节名要叫信息的表示和处理呢？细细思索一番才觉恍然，原因正是作者在第一章就说明了的一件事：**信息就是位加上下文**。

在计算机系统中，无论是程序、用户数据乃至磁盘文件，都是由一个个的二进制位来表示的--对，计算机里的无论什么东西，都只有0和1。那计算机如何区分不同的对象呢？靠的就是上下文信息。

正好最近在读王爽的《汇编语言》，就拿8086CPU来举例。对于8086来说，区分数据和指令的途径就是寄存器的值。CS:IP寄存器指向的数据被当做指令来执行；DS:(偏移地址)指向的数据就当做普通数据来对待。

无论是数据还是可执行的指令，在计算机内部并无任何区别，区别只是在于CPU对待它们的方式不同而已。所以本章看似再讲数据的处理，其实所有信息的处理方式都不外乎于此。

## 2.1 信息存储

### 2.1.1 位、字长和字节

位、字长和字节的概念不再赘述，这里探讨一下为何提出这些概念。

一个0或1就是一位(bit)，是计算机能够表示的最小信息。所以位的概念至关重要。那为何要把8位称为一个字节，提出字节的概念呢？固然是在表示大量数据时有了更方便的表述，但字节的概念还有更重要的意义：**大多数计算机使用8位的块作为最小的可寻址的内存单元**。

字节用来寻址，那字长呢？字长用来指明指针数据的标称大小(nominal size)，一个字长为w位的机器，虚拟地址的范围为0~2$$w -1，程序最多访问2w个字节。现在明白为什么4GB内存以上的电脑要装64位Windows了吧？

### 2.1.2 32位和64位程序的区别

那32位Windows和64位Windows，或者是说32位程序和64位程序的区别是什么？

我们知道，大多数的64位机器可以运行32位机器编译的程序，这是一种向后兼容。如果我们用一下命令编译一个程序：

```shell
gcc -m32 program.c
```

得到的程序就是32位的程序，可以在32位或者64位机器上运行。如果我们编译时用的指令是：

```shell
gcc -m64 program.c
```

那就只能在64位机器上运行。因此，32位和64位程序的区别在于该程序是如何编译的。

拿C语言来说，编译方式的不同导致了各数据类型所分配的字节数可能不同。下面是一个简单地对照表：

| 有符号           | 无符号            | 32位  | 64位  |
| ------------- | -------------- | ---- | ---- |
| [signed] char | unsigned char  | 1    | 1    |
| short         | unsigned short | 2    | 2    |
| int           | unsigned       | 4    | 4    |
| long          | unsigned long  | 4    | 8    |
| int32_t       | uint32_t       | 4    | 4    |
| int64_t       | uint64_t       | 8    | 8    |
| char *        |                | 4    | 8    |
| float         |                | 4    | 4    |
| double        |                | 8    | 8    |

注意long和char *类型在不同位数机器上的不同表现。

### 2.1.3 大端和小端

大端和小端的名字来源于《格列佛游记》。《格列佛游记》记载了Lilliput和Blefuscu两个国家为了争论吃鸡蛋应该从大头打破还是从小头打破而战争不断的故事。

而对大端和小端选择的争辩也正如鸡蛋从哪头打破更好的争论一样，毫无意义，他们只是两种通用的规则罢了。对于一个ω位的整数，其位表示为![公式名](http://latex.codecogs.com/png.latex?[x_{w-1}, x_{w-2}..., x_0])其中![x_w-1](http://latex.codecogs.com/png.latex?x_{w-1})是最高有效位，而![公式名](http://latex.codecogs.com/png.latex?x_0)是最低有效位。假设ω是8的倍数，这些位可以被分组为字节，最高有效位字节为[![公式名](http://latex.codecogs.com/png.latex?[x_{w-1}, x_{w-2}, ..., x_{w-8}])最低有效位字节为：![公式名](http://latex.codecogs.com/png.latex?[x_7, x_6, ..., x_0])。某些机器按照从最低字节到最高字节的顺序来存储，称为小端法(little endian)，有些机器按照最高字节到最低字节的顺序来存储，称为大端法(big endian)。

现在很多新的处理器都支持双端法(bi-endian)，即可以自由配置为大端或者小端机器。但受操作系统所限，一旦选定了操作系统，字节顺序也就固定下来了。一般而言现在的Linux和Windows都是采用的小端法。

### 2.1.4 C语言中的移位运算

C语言提供了<<和>>两个运算符来支持移位运算，表达式x<<k向左移动k位，即丢弃最高的k位，并在右端补k个0。

右移运算相较于左移略微麻烦，机器支持两种形式的右移：逻辑右移和算术右移。对于运算x>>k，逻辑右移在左端补k个0，算术右移在左端补k个最高有效位的值。下面通过例子说明，设x为10010101

| 操作           | 值          |
| ------------ | ---------- |
| x << 4       | 0101*0000* |
| x >> 4(逻辑右移) | *0000*1001 |
| x >> 4(算术右移) | *1111*1001 |

斜体部分是填充的值。

C语言并没有规定对于有符号数使用哪种右移方式，但几乎所有的机器和编译器都会使用算术右移。而对于无符号数，右移一定是逻辑右移。

## 2.2 整数的表示

计算机中对数字的表示有三种重要的方法。一种是补码(two's complement)形式，一种是无符号的形式，另一种就是浮点数形式。前两种方式都用来表示较小的整数。

### 2.2.1 无符号数编码

无符号编码就是一个二进制数字的位表示形式， 按照不同位数的权值将其相加即是数的值。

但无符号编码只能表示非负数，而我们经常会用到负数。表示负数的最常用的编码形式就是补码形式。

补码的第一位