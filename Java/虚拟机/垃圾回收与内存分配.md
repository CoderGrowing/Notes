# 垃圾回收与内存分配

Java比起C++ 很大的一点改进就是采用了自动内存分配机制。程序员不需要再自行申请、释放内存，Java虚拟机会帮你管理好这一切。那么Java虚拟机是如何解决垃圾回收的呢？首先要解决的第一个问题就是，如何判断对象的生存状态。

### 1. 判断对象的生存状态

#### 1.1 引用计数法（Reference Counting）

引用计数法是一种很简单的判断对象是否存活的机制：给对象添加一个引用计数器，每当有一个地方引用它时，计数器的值就加1；当引用失效时计数器就减1；当计数器为0时对象就无法使用，即“已经死亡”，可以进行垃圾回收了。

引用计数最大的问题在于无法解决循环引用的问题。

#### 1.2 可达性分析（Reachability Analysis）

Java中的判断对象生存状态的算法是可达性分析。它会通过一系列的称为“GC Roots"的对象为起点，从这些节点开始向下搜索，搜索走过的路径称为引用链（Reference Chain），当一个对象到GC Roots没有任何引用时，对象就已死。

Java中可以充当GC Roots的对象包括以下几种：

- 虚拟机栈（栈帧中的本地变量表）中引用的对象
- 方法区中类静态属性引用的对象
- 方法区中常量引用的对象
- 本地方法栈中JNI引用的对象

#### 1.3 引用

JDK1.2之后引用的概念得到了扩充，被分为了多种引用类型：

- 强引用（Strong Reference）：普遍存在的，比如new一个对象赋值的引用。只要强引用存在就永远不会回收该对象
- 软引用（Soft Reference）：描述一些还有用但并非必须的对象，在系统将要发生内存溢出异常之前，才会把这些对象列入回收范围进行第二次回收，如果回收完了仍然没有足够的内存，才会抛出内存溢出异常。SoftReference类来实现软引用
- 弱引用（Weak Reference）：弱引用的强度更弱，被弱引用的对象只能生存到下一次垃圾回收发生之前。当垃圾回收器工作时，无论内存是否足够，弱引用对象都会被回收。利用WeakReference类来实现弱引用。
- 虚引用（Phantom Reference）：也称为幽灵引用或者幻影引用，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。PhantomReference类来实现虚引用。

#### 1.4 生存还是死亡

即使在可达性分析算法中不可达的对象，也并非是“非死不可”的，这时候它们暂时处于“缓刑”阶段，要真正宣告一个对象死亡，至少要经历两次标记过程：如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链，那它将会被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行finalize（）方法。当对象没有覆盖finalize（）方法，或者finalize（）方法已经被虚拟机调用过，虚拟机将这两种情况都视为“没有必要执行”。

如果这个对象被判定为有必要执行finalize（）方法，那么这个对象将会放置在一个叫做F-Queue的队列之中，并在稍后由一个由虚拟机自动建立的、低优先级的Finalizer线程去执行它。finalize（）方法是对象逃脱死亡命运的最后一次机会，稍后GC将对F-Queue中的对象进行第二次小规模的标记，如果对象要在finalize（）中成功拯救自己——只要重新与引用链上的任何一个对象建立关联即可，譬如把自己（this关键字）赋值给某个类变量或者对象的成员变量，那在第二次标记时它将被移除出“即将回收”的集合；如果对象这时候还没有逃脱，那基本上它就真的被回收了。

另外，每个对象的finalize()方法只会被系统调用一次，如果对象面临下一次回收，它的finalize（）方法不会被再次执行。

### 2. 垃圾回收算法

#### 2.1 标记-清除算法

算法分为标记和清除两个阶段，首先标记处所有需要回收的对象，在标记完成后统一回收所有被标记的对象。

算法执行过程如图所示，上面的为回收前，后面的为回收后。

![](http://oqag5mdvp.bkt.clouddn.com/201804221154_279.png)

它的不足主要有两个：一是效率问题，标记和清除两个过程的效率都不太高；二是空间问题，标记清除后会产生大量不连续的内存碎片。

#### 2.2 复制算法

它将可用内存划分为大小相等的两块，每次只使用其中的一块。当这一块内存用完了，就将还存活的对象复制到另一块上，然后再把已经使用过的内存空间一次清理掉。

![](http://oqag5mdvp.bkt.clouddn.com/201804221156_634.png)

代价是将内存缩小到了原来的一般，代价有点高。现在的商业虚拟机一般都采用此算法来回收新生代，98%的

#### 2.3 标记-整理算法

标记整理算法同样分为两个步骤，标记的过程和标记-清除算法相同，但它的后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象向一端移动，然后直接清理掉端边界之外的内存。

![](http://oqag5mdvp.bkt.clouddn.com/201804221159_943.png)

#### 2.4 分代收集算法

分代收集算法根据对象存活周期的不同将内存划分为几块，一般是将Java堆分为新生代和老年代，然后根据不同年代的特点采用不同的收集算法。新生代中每次垃圾收集都有大量对象死去，就选用复制算法，这样只需要付出少量对象复制成本就可以完成收集；老年代中存活率较高，就采用标记-整理或者标记-清除算法。

### 3. HotSpot的算法实现

上面的都是理论知识，下面看一下主流的HotSpot虚拟机是如何实际实现这些算法的。

#### 3.1 枚举根节点

可作为GC Roots的节点主要是全局性的引用（常量和静态变量）和执行上下文（栈帧中的本地变量表）。若要逐个检查里边的引用，时间的耗费巨大。

其次，每次GC时都需要暂停所有Java执行线程（Stop The World），否则对象引用关系在不断变化可能导致GC不准确。

HotSpot虚拟机使用了一组叫做OopMap的数据结构，直接存放对象的引用。这样，当GC扫描时可以直接得知引用信息，大大提升效率。

#### 3.2 安全点

若为每一条指令都生成对应的OopMap会占用大量的额外空间，导致GC成本过高。为了解决这个问题，HotSpot引入了安全点（SafePoint）的概念，只在安全点处记录OopMap信息。即程序执行时并非在所有地方都能停顿下来开始GC，只有在到达安全点时才能暂停。

那么线程怎么知道自己是否到了安全点了呢？有两种方案：抢先式中断（Preemptive Suspension）和主动式中断（Voluntary Suspension）。

抢先式中断不需要线程的执行代码主动去配合，在GC发生时，首先把所有线程全部中断，如果发现有线程中断的地方不在安全点上，就恢复线程，让它“跑”到安全点上。现在几乎没有虚拟机实现采用抢先式中断来暂停线程从而响应GC事件。
主动式中断的思想是当GC需要中断线程的时候，不直接对线程操作，仅仅简单地设置一个标志，各个线程执行时主动去轮询这个标志，发现中断标志为真时就自己中断挂起。

#### 3.3 安全区域

安全点仍然没有解决所有的问题。试想，当线程被sleep的时候，它怎么跑到安全点去响应GC事件呢？这时需要安全区域（Safe Area）来解决。

安全区域是指在一段代码片段之中，引用关系不会发生变化。在这个区域中的任意地方开始GC都是安全的。可以把Safe Region看做是被扩展了的Safepoint。

在线程执行到Safe Region中的代码时，首先标识自己已经进入了Safe Region，那样，当在这段时间里JVM要发起GC时，就不用管标识自己为Safe Region状态的线程了。在线程要离开Safe Region时，它要检查系统是否已经完成了根节点枚举（或者是整个GC过程），如果完成了，那线程就继续执行，否则它就必须等待直到收到可以安全离开Safe Region的信号为止。

### 4. 垃圾回收器

JDK1.7对应的虚拟机使用如下几种垃圾回收器：

![](http://oqag5mdvp.bkt.clouddn.com/201804291913_703.png)

虚拟机会根据场景的不同选择不同的垃圾回收器和垃圾回收算法。

### 5. 内存分配和回收策略

对象的内存分配主要是在堆上进行，对象主要分配在新生代的Eden区，也有少数情况会直接分配在老年代中。下面是几条基本的分配规则。

#### 5.1 对象优先在Eden区分配

大多数情况下，对象在新生代Eden区中分配。当Eden区没有足够空间进行分配时，虚拟机将发起一次Minor GC。

- **新生代GC(Minor GC)**：指发生在新生代中的垃圾回收，Java对象大都朝生夕灭，Minor GC非常频繁，一般回收速度也快
- **老年代GC(Major GC/ Full GC)**：发生在老年代的GC，一般速度比Minor GC慢10倍以上。

#### 5.2 大对象直接进入老年代

所谓的大对象是指，需要大量连续内存空间的Java对象，最典型的大对象就是那种很长的字符串以及数组。

#### 5.3 长期存活的对象直接进入老年代

虚拟机给每个对象定义了一个对象年龄计数器，如果对象在Eden出生并经过第一次Minor GC后仍然存活，并且能被Survivor容纳的话，将被移动到Survivor空间中，并且对象年龄设为1。对象在Survivor区中每“熬过”一次Minor GC，年龄就增加1岁，当它的年龄增加到一定程度（默认为15岁），就将会被晋升到老年代中。

#### 5.4 动态对象年龄判定

为了能更好地适应不同程序的内存状况，虚拟机并不是永远地要求对象的年龄必须达到了MaxTenuringThreshold才能晋升老年代，如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无须等到MaxTenuringThreshold中要求的年龄。