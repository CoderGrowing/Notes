# 垃圾回收与内存分配

Java 比起 C++ 很大的一点改进就是采用了自动内存分配机制。程序员不需要再自行申请、释放内存，Java 虚拟机会帮你管理好这一切。那么 Java 虚拟机是如何解决垃圾回收的呢？

首先要解决的第一个问题就是，如何判断对象的生存状态。

## 1. 判断对象的生存状态

### 1.1 引用计数法（Reference Counting）

引用计数法是一种很简单的判断对象是否存活的机制：给对象添加一个引用计数器，每当有一个地方引用它时，计数器的值就加 1；当引用失效时计数器就减 1；当计数器为 0 时对象就无法使用，即“已经死亡”，可以进行垃圾回收了。

引用计数最大的问题在于无法解决循环引用的问题。

#### 1.2 可达性分析（Reachability Analysis）

Java 中的判断对象生存状态的算法是可达性分析。它会通过一系列的称为「**GC Roots**」的对象为起点，从这些节点开始向下搜索。搜索走过的路径称为引用链（Reference Chain），当一个对象到 GC Roots 没有任何引用时，就表明对象已死。

Java 中可以充当 GC Roots 的对象包括以下几种：

- 虚拟机栈（栈帧中的本地变量表）中引用的对象
- 方法区中类静态属性引用的对象
- 方法区中常量引用的对象
- 本地方法栈中 JNI 引用的对象

#### 1.3 引用

JDK1.2 之后引用的概念得到了扩充，被分为了多种引用类型：

- **强引用**（Strong Reference）：普遍存在的，比如 new 一个对象赋值的引用。只要强引用存在就永远不会回收该对象
- **软引用**（Soft Reference）：描述一些还有用但并非必须的对象，在系统将要发生内存溢出异常之前，才会把这些对象列入回收范围进行第二次回收，如果回收完了仍然没有足够的内存，才会抛出内存溢出异常。 SoftReference 类来实现软引用
- **弱引用**（Weak Reference）：弱引用的强度更弱，被弱引用的对象只能生存到下一次垃圾回收发生之前。当垃圾回收器工作时，无论内存是否足够，弱引用对象都会被回收。利用 WeakReference 类来实现弱引用。
- **虚引用**（Phantom Reference）：也称为幽灵引用或者幻影引用，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。PhantomReference 类来实现虚引用。

#### 1.4 生存还是死亡

即使对于可达性分析算法中不可达的对象，也并非是“非死不可”的。这时候它们暂时处于“缓刑”阶段，要真正宣告一个对象死亡，至少要经历两次标记过程：

如果对象在进行可达性分析后发现没有与 GC Roots 相连接的引用链，那它将会被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行 finalize() 方法。当对象没有覆盖 finalize() 方法，或者 finalize() 方法已经被虚拟机调用过，虚拟机将这两种情况都视为“没有必要执行”。

如果这个对象被判定为有必要执行 finalize() 方法，那么这个对象将会放置在一个叫做 F-Queue 的队列之中，并在稍后由一个由虚拟机自动建立的、低优先级的 Finalizer 线程去执行它。finalize() 方法是对象逃脱死亡命运的最后一次机会，稍后 GC 将对 F-Queue 中的对象进行第二次小规模的标记，如果对象要在 finalize（）中成功拯救自己——只要重新与引用链上的任何一个对象建立关联即可，譬如把自己（this 关键字）赋值给某个类变量或者对象的成员变量，那在第二次标记时它将被移除出“即将回收”的集合；如果对象这时候还没有逃脱，那基本上它就真的被回收了。

另外，每个对象的 finalize() 方法只会被系统调用一次，如果对象面临下一次回收，它的 finalize()  方法不会被再次执行，而是直接被虚拟机回收。

## 2. 垃圾回收算法

### 2.1 标记 - 清除算法

算法分为标记和清除两个阶段，首先标记处所有需要回收的对象，在标记完成后统一回收所有被标记的对象。

算法执行过程如图所示，上面的为回收前，后面的为回收后。

![](http://oqag5mdvp.bkt.clouddn.com/201804221154_279.png)

它的不足主要有两个：一是效率问题，标记和清除两个过程的效率都不太高；二是空间问题，标记清除后会产生大量不连续的内存碎片。

### 2.2 复制算法

它将可用内存划分为大小相等的两块，每次只使用其中的一块。当这一块内存用完了，就将还存活的对象复制到另一块上，然后再把已经使用过的内存空间一次清理掉。

![](http://oqag5mdvp.bkt.clouddn.com/201804221156_634.png)

缺点是将内存缩小到了原来的一般，代价有点高。

现在的商业虚拟机一般都采用此算法来回收新生代。新生代中 98% 的对象都是「朝生夕死」的，所以并不按照 1：1 的比例来划分内存空间，而是将内存空间分为一块较大的 Eden 空间和两块较小的 Survivor 空间，每次使用 Eden 和其中一块 Survivor 空间。进行回收时，将 Eden 和 Survivor 中还存活着的对象一次性的复制到另一块 Survivor 空间上，最后清理掉 Eden 和刚刚用过的 Survivor 空间。HotSpot 虚拟机默认的 Eden 和 Survivor 的大小是 8：1。

### 2.3 标记 - 整理算法

标记整理算法同样分为两个步骤，标记的过程和标记 - 清除算法相同，但它的后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象向一端移动，然后直接清理掉端边界之外的内存。

![](http://oqag5mdvp.bkt.clouddn.com/201804221159_943.png)

#### 2.4 分代收集算法

分代收集算法根据对象存活周期的不同将内存划分为几块，一般是将 Java 堆分为新生代和老年代，然后根据不同年代的特点采用不同的收集算法。新生代中每次垃圾收集都有大量对象死去，就选用复制算法，这样只需要付出少量对象复制成本就可以完成收集；老年代中存活率较高，就采用标记 - 整理或者标记 - 清除算法。

## 3. HotSpot 的算法实现

上面的都是理论知识，下面看一下主流的 HotSpot 虚拟机是如何实际实现这些算法的。

### 3.1 枚举根节点

可作为 GC Roots 的节点主要是全局性的引用（常量和静态变量）和执行上下文（栈帧中的本地变量表）。若要逐个检查里边的引用，时间的耗费巨大。其次，每次 GC 时都需要暂停所有 Java 执行线程（Stop The World），否则对象引用关系在不断变化可能导致 GC 不准确。

HotSpot 虚拟机使用了一组叫做 OopMap 的数据结构，直接存放对象的引用。这样，当 GC 扫描时可以直接得知引用信息，大大提升效率。

### 3.2 安全点

若为每一条指令都生成对应的 OopMap 会占用大量的额外空间，导致 GC 成本过高。为了解决这个问题，HotSpot 引入了安全点（SafePoint）的概念，只在安全点处记录 OopMap 信息。即程序执行时并非在所有地方都能停顿下来开始 GC，只有在到达安全点时才能暂停。

那么线程怎么知道自己是否到了安全点了呢？有两种方案：抢先式中断（Preemptive Suspension）和主动式中断（Voluntary Suspension）。

抢先式中断不需要线程的执行代码主动去配合，在 GC 发生时，首先把所有线程全部中断，如果发现有线程中断的地方不在安全点上，就恢复线程，让它“跑”到安全点上。现在几乎没有虚拟机实现采用抢先式中断来暂停线程从而响应 GC 事件。
主动式中断的思想是当 GC 需要中断线程的时候，不直接对线程操作，仅仅简单地设置一个标志，各个线程执行时主动去轮询这个标志，发现中断标志为真时就自己中断挂起。

### 3.3 安全区域

安全点仍然没有解决所有的问题。试想，当线程被 sleep 的时候，它怎么跑到安全点去响应 GC 事件呢？这时需要安全区域（Safe Area）来解决。

安全区域是指在一段代码片段之中，引用关系不会发生变化。在这个区域中的任意地方开始 GC 都是安全的。可以把 Safe Region 看做是被扩展了的 Safepoint。

在线程执行到 Safe Region 中的代码时，首先标识自己已经进入了 Safe Region，那样，当在这段时间里 JVM 要发起 GC 时，就不用管标识自己为 Safe Region 状态的线程了。在线程要离开 Safe Region 时，它要检查系统是否已经完成了根节点枚举（或者是整个 GC 过程），如果完成了，那线程就继续执行，否则它就必须等待直到收到可以安全离开 Safe Region 的信号为止。

## 4. 垃圾收集器

HotSpot 虚拟机使用的几种垃圾收集器：

![](http://oqag5mdvp.bkt.clouddn.com/201804291913_703.png)

虚拟机会根据场景的不同选择不同的垃圾回收器和垃圾回收算法。

### 4.1 Serial 收集器

Serial 收集器是最基本、历史最悠久的收集器，它采用单线程来进行收集工作。下图是 Serial/Serial Old 收集器的运行过程。

![](http://oqag5mdvp.bkt.clouddn.com/201806280824_476.png)

Serial 收集器的缺点在于效率，它只能使用一个线程去进行垃圾收集，而且收集时必须停止所有工作线程，直到它收集完成。但它也有自己的优点，Serial 实现简单，没有与线程交互的开销。

### 4.2 ParNew 收集器

ParNew 收集器大致相当于 Serial 收集器的多线程版本，它的一个优势在于，除了 Serial 收集器外，只有它可以和 CMS 收集器配合工作。

### 4.3 Parallel Scavenge 收集器

Parallel Scavenge 收集器是一个新生代收集器，它采用复制算法来进行垃圾收集。特点是它的关注点与其他收集器不同。CMS 等收集器的关注点是尽可能地缩短垃圾收集时用户线程的停顿时间，而 Parallel Scavenge 收集器的目标则是达到一个可控制的吞吐量（Throughput）。

所谓吞吐量就是 CPU 用于运行用户代码的时间与 CPU 总消耗时间的比值，即吞吐量 = 运行用户代码时间 /（运行用户代码时间 + 垃圾收集时间），虚拟机总共运行了 100 分钟，其中垃圾收集花掉 1 分钟，那吞吐量就是 99%。

概括地说，吞吐量越高，CPU 利用就越高，但垃圾收集停顿的时间可能就越长，交互性差；而停顿时间越短，交互性就越好，但吞吐量会变差， CPU 利用率会变低。

### 4.4 Parallel Old 收集器

Parallel Old 收集器是 Parallel Scavenge 收集器的老年代版本，使用「标记 - 整理」算法。它可以与 Parallel Scavenge 收集器配合使用，在注重吞吐量以及 CPU 资源敏感的条件下可以取得不错的效果。

### 4.5 CMS 收集器

CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。它采用「标记 - 清除」算法来进行垃圾收集。相对而言，它的运作过程较为复杂，分为四个步骤：

- 初始标记（CMS initial mark）
- 并发标记（CMS concurrent mark）
- 重新标记（CMS remark）
- 并发清除（CMS concurrent sweep）

在初始标记和重新标记步骤中，需要 Stop The World。初始标记阶段，CMS 仅仅是标记一下 GC Roots 能直接关联到的对象，速度很快。并发标记就是进行 GC Roots Tracing 的过程，而重新标记则是为了修正并发标记期间因用户线程运作而产生变动的那部分对象的标记记录。整个运作过程如下图所示，耗时最长的并发标记和并发清除工作是与用户线程一同执行的。

![](http://oqag5mdvp.bkt.clouddn.com/201806280856_753.png)

缺点：

- 对 CPU 资源非常敏感。并发阶段需要占用较大的 CPU 资源
- 无法处理浮动垃圾（Floating Garbage）。由于 CMS 并发清理阶段用户线程还在运行着，自然就还会有新的垃圾不断产生，这一部分垃圾出现在标记过程之后，CMS 无法在当次收集中处理掉它们，只好留待下一次 GC 时再清理掉。这一部分垃圾就称为「浮动垃圾」。
- CMS 基于标记 - 清除算法，收集后会产生大量的空间碎片。

### 4.6 G1 收集器



## 5. 内存分配和回收策略

对象的内存分配主要是在堆上进行，对象主要分配在新生代的 Eden 区，也有少数情况会直接分配在老年代中。下面是几条基本的分配规则。

### 5.1 对象优先在 Eden 区分配

大多数情况下，对象在新生代 Eden 区中分配。当 Eden 区没有足够空间进行分配时，虚拟机将发起一次 Minor GC。

![](http://oqag5mdvp.bkt.clouddn.com/201806280935_608.png)

- **新生代 GC(Minor GC)**：指发生在新生代中的垃圾回收，Java 对象大都朝生夕灭，Minor GC 非常频繁，一般回收速度也快
- **老年代 GC(Major GC/ Full GC)**：发生在老年代的 GC，一般速度比 Minor GC 慢 10 倍以上。

### 5.2 大对象直接进入老年代

所谓的大对象是指，需要大量连续内存空间的 Java 对象，最典型的大对象就是那种很长的字符串以及数组。

### 5.3 长期存活的对象直接进入老年代

虚拟机给每个对象定义了一个对象年龄计数器，如果对象在 Eden 出生并经过第一次 Minor GC 后仍然存活，并且能被 Survivor 容纳的话，将被移动到 Survivor 空间中，并且对象年龄设为 1。对象在 Survivor 区中每“熬过”一次 Minor GC，年龄就增加 1 岁，当它的年龄增加到一定程度（默认为 15 岁），就将会被晋升到老年代中。

### 5.4 动态对象年龄判定

为了能更好地适应不同程序的内存状况，虚拟机并不是永远地要求对象的年龄必须达到了 MaxTenuringThreshold 才能晋升老年代，如果在 Survivor 空间中相同年龄所有对象大小的总和大于 Survivor 空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无须等到 MaxTenuringThreshold 中要求的年龄。

### 5.5 空间分配担保

在发生 Minor GC 之前，虚拟机会检查老年代最大可用的连续空间是否大于新生代所有对象的总空间，如果大于，则 Minor GC 是安全的。否则，虚拟机会检查 HandlePromotionFailure 设置值是否为允许失败。如果允许，会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次 Minor GC。如果小于，或者 HandlePromotionFailure 设置不允许失败，改为进行一次 Full GC。

HandlePromotionFailure 参数的设置决定了虚拟机是否进行空间分配担保。我们前面说过新生代共有三块内存空间，Eden 和两块 Survivor。当存活的对象较多，用于复制的那块 Survivor 空间无法容纳时，可以利用将 Survivor 空间中的部分对象直接进入老年代的方法来提供更多的空间，即分配担保。当然，当存活对象非常多时，依然会出现担保失败的情况（老年代最大连续内存也无法容纳对象）。如果出现了 HandlePromotionFailure 失败，则需要进行一次 Full GC。