# 垃圾回收与内存分配

Java比起C++ 很大的一点改进就是采用了自动内存分配机制。程序员不需要再自行申请、释放内存，Java虚拟机会帮你管理好这一切。那么Java虚拟机是如何解决垃圾回收的呢？首先要解决的第一个问题就是，如何判断对象的生存状态。

### 1. 判断对象的生存状态

#### 1.1 引用计数法（Reference Counting）

引用计数法是一种很简单的判断对象是否存活的机制：给对象添加一个引用计数器，每当有一个地方引用它时，计数器的值就加1；当引用失效时计数器就减1；当计数器为0时对象就无法使用，即“已经死亡”，可以进行垃圾回收了。

引用计数最大的问题在于无法解决循环引用的问题。

#### 1.2 可达性分析（Reachability Analysis）

Java中的判断对象生存状态的算法是可达性分析。它会通过一系列的称为“GC Roots"的对象为起点，从这些节点开始向下搜索，搜索走过的路径称为引用链（Reference Chain），当一个对象到GC Roots没有任何引用时，对象就已死。

Java中可以充当GC Roots的对象包括以下几种：

- 虚拟机栈（栈帧中的本地变量表）中引用的对象
- 方法区中类静态属性引用的对象
- 方法区中常量引用的对象
- 本地方法栈中JNI引用的对象

#### 1.3 引用

JDK1.2之后引用的概念得到了扩充，被分为了多种引用类型：

- 强引用（Strong Reference）：普遍存在的，比如new一个对象赋值的引用。只要强引用存在就永远不会回收该对象
- 软引用（Soft Reference）：描述一些还有用但并非必须的对象，在系统将要发生内存溢出异常之前，才会把这些对象列入回收范围进行第二次回收，如果回收完了仍然没有足够的内存，才会抛出内存溢出异常。SoftReference类来实现软引用

### 2. 垃圾回收算法

#### 2.1 标记-清除算法

算法分为标记和清除两个阶段，首先标记处所有需要回收的对象，在标记完成后统一回收所有被标记的对象。

算法执行过程如图所示，上面的为回收前，后面的为回收后。

![](http://oqag5mdvp.bkt.clouddn.com/201804221154_279.png)

它的不足主要有两个：一是效率问题，标记和清除两个过程的效率都不太高；二是空间问题，标记清除后会产生大量不连续的内存碎片。

#### 2.2 复制算法

它将可用内存划分为大小相等的两块，每次只使用其中的一块。当这一块内存用完了，就将还存活的对象复制到另一块上，然后再把已经使用过的内存空间一次清理掉。

![](http://oqag5mdvp.bkt.clouddn.com/201804221156_634.png)

代价是将内存缩小到了原来的一般，代价有点高。现在的商业虚拟机一般都采用此算法来回收新生代，98%的

#### 2.3 标记-整理算法

标记整理算法同样分为两个步骤，标记的过程和标记-清除算法相同，但它的后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象向一端移动，然后直接清理掉端边界之外的内存。

![](http://oqag5mdvp.bkt.clouddn.com/201804221159_943.png)

#### 2.4 分代收集算法

分代收集算法根据对象存活周期的不同将内存划分为几块，一般是将Java堆分为新生代和老年代，然后根据不同年代的特点采用不同的收集算法。新生代中每次垃圾收集都有大量对象死去，就选用复制算法，这样只需要付出少量对象复制成本就可以完成收集；老年代中存活率较高，就采用标记-整理或者标记-清除算法。

