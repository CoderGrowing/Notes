# Java 内存区域划分与对象存储

## 1. Java 虚拟机划分的内存区域

![](http://oqag5mdvp.bkt.clouddn.com/201804151949_244.jpg)

如图所示，蓝色为线程共享，绿色为线程私有数据。

**方法区（Method Area）：**

方法区是属于**线程共享**的内存区域，又称作 Non-Heap（非堆），主要存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。

**JVM 堆（Java Heap）**

Java 堆同样是**线程共享**的内存区域，它在虚拟机启动时创建，是 Java 虚拟机管理的内存中最大的一块。所有的对象实例以及数组都要在堆上分配。有时也被称为 GC 堆。

**程序计数器（Program Counter Register）**

线程私有，指向下一个要执行的字节码。如果线程正在执行一个 Java 方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果执行的是 Native 方法，这个计数器为空（Undefined）。这个内存区域是在 Java 虚拟机规范中唯一一个没有规定任何 OutOfMemoryError 的区域。

**虚拟机栈（Java Virtual Machines Stacks）**

线程私有，生命周期与线程相同，代表了 Java 执行的内存模型。每个方法执行的同时都会创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用到执行完成完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。

**本地方法栈（Native Method Stacks）**

线程私有，主要与虚拟机用到的 Native 方法有关，一般无需关心。一些虚拟机的实现（如 Sun HotSpot）会将本地方法栈和虚拟机栈合二为一。

**运行时常量池（Runtime Constant Pool）**

运行时常量池是方法区的一部分，Class 文件中除了有类的版本、字段、方法、接口等信息外，还有一项信息就是常量池，用于存放编译期生成的各种字面量和符号引用。

## 2. 对象的创建

虚拟机遇到一条 new 指令时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并检查这个符号引用所代表的类是否已被加载、解析和初始化过。如果没有，则先进行类的加载过程。

### 2.1 两种分配方式

加载检查通过后，虚拟机将开始为新生对象分配内存。 

如果 Java 堆中内存是绝对规整的，所有用过的内存都放在一边，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅是把那个指针向空闲空间那边挪动一段与对象大小相等的距离，这种分配方式称为**“指针碰撞”（Bump the Pointer）。**

如果内存并不规整，则虚拟机会维护一个列表，记录哪些内存块是可用的，分配的时候在表上找到一块足够大的空间划分给实例（对象的大小在加载时已经确定），并更新表的记录。这种分配方式被称为**空闲列表（Free List）。**

选择哪种分配方式由 Java 堆是否规整决定，而 Java 堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。因此，在使用 Serial、ParNew 等带 Compact 过程的收集器时，系统采用的分配算法是指针碰撞，而使用   CMS 这种基于 Mark-Sweep 算法的收集器时，通常采用空闲列表。

### 2.2 并发情况下的线程安全

即使是仅仅修改一个指针所指向的位置，在并发情况下也不是线程安全的。为了保证创建对象的线程安全，主要有两种解决方案。一种是对分配内存空间的动作进行同步处理——实际上虚拟机采用 CAS 配上失败重试的方式保证更新操作的原子性。

另一种方式是把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在 Java 堆中预先分配一小块内存，称为**本地线程分配缓冲（Thread Local Allocation Buffer，TLAB）。哪个线程要分配内存，就在哪个线程的 TLAB 上分配，只有 TLAB 用完并分配新的 TLAB 时，才需要同步锁定。虚拟机是否使用 TLAB，可以通过 -XX：+/-UseTLAB 参数来设定。

接下来虚拟机将分配到的内存空间都初始化为零值（不包含对象头），如果使用了 TLAB，这一操作也可以提前至 TLAB 分配时进行。这一操作保证了对象的实例字段可以在不赋初始值时就直接使用。而后虚拟机对对象进行必要的设置，如类的元数据信息、对象的哈希码、GC 年代信息等。

## 3. 对象的内存布局

在 HotSpot 虚拟机中，对象在内存中存储的布局可以分为 3 块区域：对象头（Header）、实例数据（Instance Data）和对齐填充（Padding）。

### 3.1 对象头

HotSpot 虚拟机的对象头包括两部分信息，第一部分用于存储对象自身的运行时数据，如哈希码、GC 分代年龄、锁状态标志、线程持有的锁、偏向线程 ID、偏向时间戳等。这部分数据的长度在 32 位虚拟机和 64 位虚拟机中分别为 32bit 和 64bit，被称为「Mark Word」。Mark Word 是一个非固定的数据结构，以便于在极小的空间内存储很多的信息。即，在不同的状态下（未锁定、轻量级锁定等），Mark Word 的内容也有所不同。不同状态下 Mark Word 存储的信息如下表所示：

| 存储内容                              | 标志位 | 状态               |
| ------------------------------------- | ------ | ------------------ |
| 对象哈希码、对象分代年龄              | 01     | 未锁定             |
| 指向锁记录的指针                      | 00     | 轻量级锁定         |
| 指向重量级锁的指针                    | 10     | 膨胀（重量级锁定） |
| 空，不需要记录                        | 11     | GC 标记            |
| 偏向进程 ID、偏向时间戳、对象分代年龄 | 01     | 可偏向             |

对象头的另一部分是类型指针。虚拟机通过这个指针来确定这个对象是哪个类的实例。如果对象是一个 Java 数组，那在对象头中还必须有一块用于记录数组长度的数据。

### 3.2 实例数据

实例数据部分是对象真正存储的有效信息，也是在程序代码中定义的各种类型的字段内容。这部分的存储顺序会受到虚拟机分配策略参数（FieldsAllocationStyle）和字段在 Java 源码中定义顺序的影响。HotSpot 虚拟机默认的分配策略为 longs/doubles、ints、shorts/chars、bytes/booleans、oops（Ordinary Object Pointers），从分配策略中可以看出，相同宽度的字段总是被分配到一起。

### 3.3. 对齐填充

对齐填充并不是必然存在的，也无特殊意义，仅仅起到占位符的作用。HotSpot 虚拟机的自动内存管理系统要求对象起始地址必须是 8 字节的倍数，因此当实例数据部分没有对齐时就需要对齐填充来进行补全。

## 4.. 对象的访问定位

Java 程序需要通过栈上的 reference 数据来操作堆上的具体对象。reference 类型在 Java 虚拟机规范中只规定了一个指向对象的引用，并没有定义如何去定位。所以具体实现方式由虚拟机来决定。目前主流的方式有**使用句柄**和**直接句柄**两种。

### 4.1 使用句柄

使用句柄方式访问的话，Java 堆会划分出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自具体的地址信息。

![](http://oqag5mdvp.bkt.clouddn.com/201804242035_466.png)

### 4.2 直接访问

使用直接指针访问的话，Java 堆对象的布局就必须考虑如何设置访问类型数据的相关信息，reference 中存储的直接就是对象地址。

![](http://oqag5mdvp.bkt.clouddn.com/201804242035_984.png)

使用句柄访问的好处是 reference 中存储的是稳定的句柄地址，当对象被移动时只会改变句柄中的实例数据指针，reference 本身不需要修改。直接指针访问的好处是速度快，节省了一次指针定位的时间开销。Hotspot 虚拟机实现是利用的直接访问。