# Java内存区域划分与对象存储

### 1. Java虚拟机划分的内存区域



![](http://oqag5mdvp.bkt.clouddn.com/201804151949_244.jpg)

如图所示，蓝色为线程共享，绿色为线程私有数据。

**方法区（Method Area）：**

方法区是属于**线程共享**的内存区域，又称作Non-Heap（非堆），主要存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。

**JVM堆（Java Heap）**

Java堆同样是**线程共享**的内存区域，它在虚拟机启动时创建，是Java虚拟机管理的内存中最大的一块。所有的对象实例以及数组都要在堆上分配。有时也被称为GC堆。

**程序计数器（Program Counter Register）**

线程私有，指向下一个要执行的字节码。如果线程正在执行一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果执行的是Native方法，这个计数器为空（Undefined）。这个内存区域是在Java虚拟机规范中唯一一个没有规定任何OutOfMemoryError的区域。

**虚拟机栈（Java Virtual Machines Stacks）**

线程私有，与线程同时创建，总数与线程个数有关。代表了Java执行的内存模型。每个方法执行的同时都会创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用到执行完成完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。

**本地方法栈（Native Method Stacks）**

线程私有，主要与虚拟机用到的Native方法有关，一般无需关心。

**运行时常量池（Runtime Constant Pool）**

运行时常量池是方法区的一部分，Class文件中除了有类的版本、字段、方法、接口等信息外，还有一项信息就是常量池，用于存放编译期生成的各种字面量和符号引用。

### 2. 对象的创建

虚拟机遇到一条new指令时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并检查这个符号引用所代表的类是否已被加载、解析和初始化过。如果没有，则先进行初始化过程。

类加载检查通过后，虚拟机将为新生对象分配内存。如果Java堆中内存是绝对规整的，所有用过的内存都放在一边，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅是把那个指针向空闲空间那边挪动一段与对象大小相等的距离，这种分配方式称为**“指针碰撞”（Bump the Pointer）。**

如果内存并不规整，则虚拟机会维护一个列表，记录哪些内存块是可用的，分配的时候在表上找到一块足够大的空间划分给实例（对象的大小在加载时已经确定），并更新表的记录。这种分配方式被称为**空闲列表（Free List）。**

接下来虚拟机将分配到的内存空间都初始化为零值（不包含对象头），而后进行必要的设置，如类的元数据信息、对象的哈希码、GC年代信息等。

### 3. 对象的内存布局

在HotSpot虚拟机中，对象在内存中存储的布局可以分为3块区域：对象头（Header）、实例数据（Instance Data）和对齐填充（Padding）。

**对象头**

HotSpot虚拟机的对象头包括两部分信息，第一部分用于存储对象自身的运行时数据，如哈希码、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等。

对象头的另一部分是类型指针。虚拟机通过这个指针来确定这个对象是哪个类的实例。如果对象是一个Java数组，那在对象头中还必须有一块用于记录数组长度的数据。

**实例数据**

实例数据部分是对象真正存储的有效信息，也是在程序代码中定义的各种类型的字段内容。

**对齐填充**

对齐填充并不是必然存在的，也无特殊意义，仅仅起到占位符的作用。

### 3. 对象的访问定位

Java程序需要通过栈上的reference数据来操作堆上的具体对象。reference类型在Java虚拟机规范中只规定了一个指向对象的引用，并没有定义如何去定位。所以具体实现方式由虚拟机来决定。目前主流的方式有**使用句柄**和**直接句柄**两种。

#### 2.1 使用句柄

使用句柄方式访问的话，Java堆会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自具体的地址信息。

![](http://oqag5mdvp.bkt.clouddn.com/201804242035_466.png)

#### 2.2 直接访问

使用直接指针访问的话，Java堆对象的布局就必须考虑如何设置访问类型数据的相关信息，reference中存储的直接就是对象地址。

![](http://oqag5mdvp.bkt.clouddn.com/201804242035_984.png)

使用句柄访问的好处是reference中存储的是稳定的句柄地址，当对象被移动时只会改变句柄中的实例数据指针，reference本身不需要修改。直接指针访问的好处是速度快，节省了一次指针定位的时间开销。Hotspot虚拟机实现是利用的直接访问。