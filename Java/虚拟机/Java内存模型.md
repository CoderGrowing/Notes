# Java内存模型

Java虚拟机规范中定义了**Java内存模型**（Java Memory Model，JMM），用于屏蔽掉各种硬件和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致的并发效果。JMM规范了Java虚拟机与计算机内存是如何协同工作的：规定了一个线程如何和何时可以看到由其他线程修改过后的共享变量的值，以及在必须时如何同步的访问共享变量。

### 1. Java虚拟机划分的内存区域



![](http://oqag5mdvp.bkt.clouddn.com/201804151949_244.jpg)

如图所示，蓝色为线程共享，绿色为线程私有数据。

**方法区（Method Area）：**

方法区是属于**线程共享**的内存区域，又称作Non-Heap（非堆），主要存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。

**JVM堆（Java Heap）**

Java堆同样是**线程共享**的内存区域，它在虚拟机启动时创建，是Java虚拟机管理的内存中最大的一块。主要用于存放对象实例。有时也被称为GC堆。

**程序计数器（Program Counter Register）**

线程私有，指向下一个要执行的字节码。

**虚拟机栈（Java Virtual Machines Stacks）**

线程私有，与线程同时创建，总数与线程个数有关。代表了Java执行的内存模型。每个方法执行的同时都会创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用到执行完成完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出战的过程。

**本地方法栈（Native Method Stacks）**

线程私有，主要与虚拟机用到的Native方法有关，一般无需关心。

### 2. 数据的存放

JMM与Java内存区域的划分是不同的概念层次。JMM是围绕原子性，有序性、可见性展开的。JMM与Java内存区域唯一相似点，都存在共享数据区域和私有数据区域。在JMM中主内存属于共享数据区域，而工作内存数据线程私有数据区域。每个线程创建时JVM都会为其创建一个工作内存，用于存储线程私有的数据。

- **主内存**：主要存储的是Java实例对象，所有线程创建的实例对象都存放在主内存中，不管该**实例对象是成员变量还是方法中的本地变量(也称局部变量)**，也包括了共享的类信息、常量、静态变量。由于是共享数据区域，多条线程对同一个变量进行访问可能会发现线程安全问题。
- **工作内存**：主要存储当前方法的所有本地变量信息，每个线程只能访问自己的工作内存，即线程中的本地变量对其它线程是不可见的。

![](http://oqag5mdvp.bkt.clouddn.com/201804151956_139.jpg)

那么变量、对象在主内存和工作内存中是如何存储的呢？

- 原始类型变量存放在工作内存的栈帧上

- 对于引用对象，这个对象的引用存放在工作内存的栈帧上，对象本身仍然存放在堆（主内存）上

- 一个对象可能包含方法，这些方法可能包含本地变量。这些本地变量仍然存放在工作内存的栈上，即使这些方法所属的对象存放在堆上。

- 一个对象的成员变量可能随着这个对象自身存放在堆上。不管这个成员变量是原始类型还是引用类型。

- 静态成员变量跟随着类定义一起也存放在堆上。

- 存放在堆上的对象可以被所有持有对这个对象引用的线程访问。当一个线程可以访问一个对象时，它也可以访问这个对象的成员变量。如果两个线程同时调用同一个对象上的同一个方法，它们将会都访问这个对象的成员变量，但是每一个线程都拥有这个成员变量的私有拷贝。 

  如下图所示：

  ![](http://oqag5mdvp.bkt.clouddn.com/201804152018_248.jpg)

### 3. 多线程应用可能出现的问题

#### 3.1 原子性

原子性指的是一个操作是不可中断的，即使在多线程的环境下，一个操作一旦开始就不会受其他线程的影响。例如：`x = 10;`这个操作就是一个原子操作，它只需要将值直接写入内存中即可。但`x = x + 1;`就不是一个原子操作，因为它包含了如下三个步骤：读x的值；将其加1；写入内存。

非原子操作在多线程的应用中就可能出现问题。例如线程A执行了 `x = x + 10;`，但执行过程中线程B就来读取x的值，那么B有可能读取到的是更新前的值，造成数据不一致。

#### 3.2 可见性

可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。

```java
// 线程1执行
i = 1;
i = 10;

// 线程2执行
j = i;
```

当线程1执行 i =10这句时，会先把i的初始值加载到CPU1的高速缓存中，然后赋值为10，那么在CPU1的高速缓存当中i的值变为10了，却没有立即写入到主存当中。此时线程2执行 j = i，它会先去主存读取i的值并加载到CPU2的缓存当中，注意此时内存当中i的值还是0，那么就会使得j的值为0，而不是10。

这就是可见性问题，线程1对变量i修改了之后，线程2没有立即看到线程1修改的值。

#### 3. 有序性

有序性即程序执行的顺序按照代码的先后顺序执行。

```java
int i = 0;              
boolean flag = false;
i = 1;                //语句1  
flag = true;          //语句2
```

从代码的顺序上来看，语句1在语句2之前，但执行起来一定是这样么？不一定。为什么？因为可能会发生**指令重排序（Instruction Recorder）**。

计算机在执行程序时，为了提高性能，编译器和处理器的常常会对指令做重排，一般分以下3种：

- 编译器优化的重排

  编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序

- 指令并行的重排

  现代处理器采用了指令级并行技术来将多条指令重叠执行。如果不存在数据依赖性(即后一个执行的语句无需依赖前面执行的语句的结果)，处理器可以改变语句对应的机器指令的执行顺序

- 内存系统的重排

  由于处理器使用缓存和读写缓存冲区，这使得加载(load)和存储(store)操作看上去可能是在乱序执行，因为三级缓存的存在，导致内存与缓存的数据同步存在时间差

指令重排序不会影响单个线程的执行，但是会影响到线程并发执行的正确性。要想并发程序正确地执行，必须要保证原子性、可见性以及有序性。只要有一个没有被保证，就有可能会导致程序运行不正确。

### 4. JMM对多线程问题提供的保证

#### 4.1 原子性

Java内存模型只保证了**基本读取和赋值**是原子性操作，如果要实现更大范围操作的原子性，可以通过`synchronized`和`Lock`来实现。由于`synchronized`和`Lock`能够保证任一时刻只有一个线程执行该代码块，那么自然就不存在原子性问题了，从而保证了原子性。

#### 4.2 可见性

Java通过提供关键字`volatile`来保证可见性。

当一个共享变量被`volatile`修饰时，它会**保证修改的值会立即被更新到主存**，当有其他线程需要读取时，它会去内存中读取新值。

而普通的共享变量不能保证可见性，因为普通共享变量被修改之后，什么时候被写入主存是不确定的，当其他线程去读取时，此时内存中可能还是原来的旧值，因此无法保证可见性。

此外，`synchronized`和`Lock`也能够保证可见性。`synchronized`和`Lock`在释放锁之前会将对变量的修改刷新到主存当中。因此可以保证可见性。

#### 4.3 有序性

同样的`synchronized`和`Lock`能够保证有序性（用了同步或者锁相当于是单个线程在执行代码，当然有序）。此外，`volatile`可以保证一部分的有序性。

除此之外，还有一个重要的**happends-before（先行发生）**原则来保证天然的有序性。

happens-before：

- **程序次序规则**：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作
- **锁定规则**：一个unLock操作先行发生于后面对同一个锁额lock操作
- **volatile变量规则**：对一个变量的写操作先行发生于后面对这个变量的读操作
- **传递规则**：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C
- **线程启动规则**：Thread对象的start()方法先行发生于此线程的每个一个动作
- **线程中断规则**：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生
- **线程终结规则**：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行
- **对象终结规则**：一个对象的初始化完成先行发生于他的finalize()方法的开始

### volatile

一旦一个共享变量（类的成员变量、类的静态成员变量）被volatile修饰之后，那么就具备了两层语义：

- 保证了可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。
- 禁止进行指令重排序。

```java
x = 2;        //语句1
y = 0;        //语句2
volatile flag = true;  //语句3
x = 4;         //语句4
y = -1;       //语句5
```

由于flag变量为volatile变量，那么在进行指令重排序的过程的时候，不会将语句3放到语句1、语句2前面，也不会讲语句3放到语句4、语句5后面。但是语句1和2、语句4和5的顺序是没有任何保证的。

#### 4.1 volatile实现原理

加入volatile关键字后生成的汇编代码会比没有volatile关键字的代码多出一个lock前缀指令。lock指令实际上相当于一个内存屏障（也成内存栅栏）。内存屏障会提供3个功能：

- 它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成
- 它会强制将对缓存的修改操作立即写入主存；
- 如果是写操作，它会导致其他CPU中对应的缓存行无效。


