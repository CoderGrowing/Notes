# Java 线程和线程安全

### 1. 线程的实现

线程使 CUP 调度的基本单位。实现线程主要有 3 种方式：使用内核线程实现、使用用户线程实现和使用用户线程加轻量级进程混合实现。

#### 1.1 使用内核线程实现

内核线程（Kernel-Level Thread，KLT）就是直接由内核支持的线程，这种线程由内核来完成线程切换，内核通过操纵调度器（Scheduler）对线程进行调度，并负责将线程的任务映射到各个处理器上。

程序一般不会直接去使用内核线程，而是去使用内核线程的一种高级接口——轻量级进程（Light Weight Process,LWP）。轻量级进程就是我们通常意义上所讲的线程，这种轻量级进程与内核线程之间 1:1 的关系称为一对一的线程模型。

![](http://oqag5mdvp.bkt.clouddn.com/201804240954_834.png)

轻量级进程实现的优点在于它有内核线程的支持，即使有一个线程在系统调用中阻塞了，也不会影响其他线程继续工作。但它也有自己的不足：首先由于是基于内核线程实现的，所以各种线程操作，如创建、析构及同步，都需要进行系统调用。而系统调用的代价相对较高，需要在用户态（User Mode）和内核态（Kernel Mode）中来回切换。其次，每个轻量级进程都需要有一个内核线程的支持，因此轻量级进程要消耗一定的内核资源（如内核线程的栈空间），因此一个系统支持轻量级进程的数量是有限的。

#### 1.2 使用用户线程实现

用户线程（User Thread，UT）广义上说就是非内核线程，从这个定义上说轻量级进程也是用户线程。而狭义上的用户线程一般指建立在用户空间的线程库上的，内核并不能感知其存在。用户线程的建立、同步和调度等完全在用户态完成，不需要内核的帮助。这种进程和用户线程之间 1：N 的关系被称为一对多的线程模型。

![](http://oqag5mdvp.bkt.clouddn.com/201804241001_609.png)



使用用户线程的优势在于不需要系统内核支援，效率较高。劣势也在于没有系统内核的支援，所有的线程操作都需要用户程序自己处理。如果程序编写不当，可能会造成整个进程的阻塞。

#### 1.3 使用用户线程加轻量级进程混合实现

在这种混合实现下，既存在用户线程，也存在轻量级进程。用户线程还是完全建立在用户空间中，因此用户线程的创建、切换、析构等操作依然廉价，并且可以支持大规模的用户线程并发。而操作系统提供支持的轻量级进程则作为用户线程和内核线程之间的桥梁，这样可以使用内核提供的线程调度功能及处理器映射，并且用户线程的系统调用要通过轻量级线程来完成，大大降低了整个进程被完全阻塞的风险。在这种混合模式中，用户线程与轻量级进程的数量比是不定的，即为 N：M 的关系：

![](http://oqag5mdvp.bkt.clouddn.com/201804241004_730.png)

### 2. Java 线程的调度

线程的调度主要分为协同式线程调度（Cooperative Threads-Scheduling）和抢占式线程调度（Preemptive Threads-Scheduling）。

协同式的调度是由线程自己决定何时切换到另一个线程上去，优点在于实现简单，而且没有同步的问题。但问题在于线程执行时间不可控，一个线程执行有问题的话整个程序就会阻塞在那里。

抢占式的调度由系统来分配执行时间，线程的切换不由线程本身来决定。线程可以通过给系统“建议”的方式来请求给自己多分配一些时间，即线程的优先级。Java 中共设置了 10 个级别的优先级。

### 3. 线程状态的转换

Java 语言定义了 5 种线程状态：

- 新建（New）：创建后尚未启动的线程处于这种状态。
- 运行（Runable）：Runable 包括了操作系统线程状态中的 Running 和 Ready，也就是处于此状态的线程有可能正在执行，也有可能正在等待着 CPU 为它分配执行时间。
- 无限期等待（Waiting）：处于这种状态的线程不会被分配 CPU 执行时间，它们要等待被其他线程显式地唤醒。以下方法会让线程陷入无限期的等待状态：
  没有设置 Timeout 参数的 Object.wait（）方法。
  没有设置 Timeout 参数的 Thread.join（）方法。
  LockSupport.park（）方法。
- 限期等待（Timed Waiting）：处于这种状态的线程也不会被分配 CPU 执行时间，不过无须等待被其他线程显式地唤醒，在一定时间之后它们会由系统自动唤醒。以下方法会让线程进入限期等待状态：
  - Thread.sleep（）方法。
  - 设置了 Timeout 参数的 Object.wait（）方法。
  - 设置了 Timeout 参数的 Thread.join（）方法。
  - LockSupport.parkNanos（）方法。
  - LockSupport.parkUntil（）方法。
- 阻塞（Blocked）：线程被阻塞了，在等待着获取到一个排他锁，这个事件将在另外一个线程放弃这个锁的时候发生；而“等待状态”则是在等待一段时间，或者唤醒动作的发生。在程序等待进入同步区域的时候，线程将进入这种状态。
- 结束（Terminated）：已终止线程的线程状态，线程已经结束执行。

几种状态的切换如下：

![](http://oqag5mdvp.bkt.clouddn.com/201804241013_544.png)

### 4. 线程安全

定义：当多个线程访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那这个对象就是线程安全的。

#### 4.1 安全程度

**1. 不可变**

不可变的对象一定是线程安全的，例如被 final 修饰的变量。

**2. 绝对线程安全**

绝对的线程安全是符合上述定义的，但 Java 中绝大多数标注线程安全的类都不是绝对的线程安全。例如对于 java.util.Vector 类，

```java
private static Vector ＜ Integer ＞ vector=new Vector ＜ Integer ＞（）；
    public static void main（String[]args）{
        while（true）{
            for（int i=0；i ＜ 10；i++）
            	vector.add（i）；

            Thread removeThread=new Thread（new Runnable（）{
                @Override
                public void run（）{
                    for（int i=0；i ＜ vector.size（)；i++)
                    	vector.remove（i）；
        	}
        }）；
        
        Thread printThread=new Thread（new Runnable（）{
            @Override
            public void run（）{
                for（int i=0；i ＜ vector.size（）；i++
                	System.out.println((vector.get（i))；
            }
        }）；
        removeThread.start（）；
        printThread.start（）；
        // 不要同时产生过多的线程，否则会导致操作系统假死
        while（Thread.activeCount（）＞ 20）；
    }
}
```

多个线程同时调用 get 和 remove 方法时，如果一个线程刚刚移除了一个元素，导致 i 已经不可用，另一个线程再去 get(i) 就会产生错误。

**3. 相对线程安全**

相对的线程安全就是我们通常意义上所讲的线程安全，它需要保证对这个对象单独的操作是线程安全的，我们在调用的时候不需要做额外的保障措施，但是对于一些特定顺序的连续调用，就可能需要在调用端使用额外的同步手段来保证调用的正确性。

**4. 线程兼容**

线程兼容是指对象本身并不是线程安全的，但是可以通过在调用端正确地使用同步手段来保证对象在并发环境中可以安全地使用，我们平常说一个类不是线程安全的，绝大多数时候指的是这一种情况。

Java API 中大部分的类都是属于线程兼容的，如 ArrayList 和 HashMap 等。

**5. 线程对立**

线程对立是指无论调用端是否采取了同步措施，都无法在多线程环境中并发使用的代码。

一个线程对立的例子是 Thread 类的 suspend（）和 resume（）方法，如果有两个线程同时持有一个线程对象，一个尝试去中断线程，另一个尝试去恢复线程，如果并发进行的话，无论调用时是否进行了同步，目标线程都是存在死锁风险的，如果 suspend（）中断的线程就是即将要执行 resume（）的那个线程，那就肯定要产生死锁了。也正是由于这个原因，suspend（）和 resume（）方法已经被 JDK 声明废弃（@Deprecated）了。

#### 4.2 实现线程安全

**1. 互斥同步**

互斥同步（Mutual Exclusion ＆ Synchronization）在多个线程并发访问共享数据时，保证共享数据在同一个时刻只被一个（或者是一些，使用信号量的时候）线程使用。临界区、互斥量、信号量等都是主要的实现互斥的方式。

Java 中最常用的互斥同步手段就是 synchronized 关键字。synchronized 关键字经过编译之后，会在同步块的前后分别形成 monitorenter 和 monitorexit 这两个字节码指令，这两个字节码都需要一个 reference 类型的参数来指明要锁定和解锁的对象。如果 Java 程序中的 synchronized 明确指定了对象参数，那就是这个对象的 reference；如果没有明确指定，那就根据 synchronized 修饰的是实例方法还是类方法，去取对应的对象实例或 Class 对象来作为锁对象。

在执行 monitorenter 指令时，首先尝试获取对象的锁，如果这个对象没被锁定，或者当前线程已经拥有了那个对象的锁，把锁的计数器加 1，相应的，在执行 monitorexit 指令时会将锁计数器减 1，当计数器为 0 时，锁就被释放。如果获取对象锁失败，那当前线程就要阻塞等待，直到对象锁被另外一个线程释放为止。

除了 synchronized 关键字外，java.util.concurrent 包中的 ReentrantLock 也可以用来实现互斥同步，它比 synchronized 关键字多了一些高级功能：

- 等待可中断：当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情
- 公平锁：多个线程在等待同一个锁的时候，必须按照申请锁的时间顺序来获得锁，ReentrantLock 默认是非公平的
- 可绑定多个条件：ReentrantLock 对象可以绑定多个 Condition 对象

**2. 非阻塞同步**

互斥同步又叫阻塞同步，是一种悲观的并发策略。

### 5. 锁优化

#### 5.1 自旋锁与自适应自旋

如果多个线程可以并行执行的话，当有两个线程同时请求锁时，我们可以让后面请求锁的那个线程“稍等一下”，但不放弃处理器的执行时间，看看持有锁的线程是否很快就会释放锁。为了让线程等待，我们只需让线程执行一个忙循环（自旋），这项技术就是所谓的自旋锁。

JDK1.6 引入了自适应的自旋锁，也就是自旋的时间不再固定，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也很有可能再次成功，进而它将允许自旋等待持续相对更长的时间。

#### 5.2 锁消除

锁消除是指虚拟机即时编译器在运行时，对一些代码上要求同步，但是被检测到不可能存在共享数据竞争的锁进行消除。

#### 5.3 锁粗化

原则上我们会将同步块的作用范围限制的尽可能的小，只有在共享数据的实际作用域才进行同步。但有时一系列的连续操作都对同一个对象反复加锁和解锁，甚至加锁操作是出现在循环体中的，那即使没有线程竞争，频繁地进行互斥同步操作也会导致不必要的性能损耗。

如果虚拟机检测到这类的操作，会把加锁同步的范围扩展到整个操作序列的外部，提高性能。

#### 5.4 轻量级锁

轻量级锁是 JDK1.6 之中加入的新型锁机制，轻量级锁的实现和 HotSpot 虚拟机的对象头的内存布局有关。

HotSpot 虚拟机的对象头（Object Header）分为两部分信息，第一部分用于存储对象自身的运行时数据，如哈希码（HashCode）、GC 分代年龄（Generational GC Age）等，这部分数据的长度在 32 位和 64 位的虚拟机中分别为 32bit 和 64bit，官方称它为“ Mark Word ”。在 32 位的 HotSpot 虚拟机中对象未被锁定的状态下，Mark Word 的 25bit 空间用于存储对象哈希码，4bit 用于存储对象分代年龄，2bit 用来存储锁标志位，1bit 固定为 0.

Mark Word 锁标志位内容如下：

| 存储内容                             | 标志位 | 状态               |
| ------------------------------------ | ------ | ------------------ |
| 对象哈希码、对象分代年龄             | 01     | 未锁定             |
| 指向锁记录的指针                     | 00     | 轻量级锁定         |
| 指向重量级锁的指针                   | 10     | 膨胀（重量级锁定） |
| 空，不需要记录信息                   | 11     | GC 标记             |
| 偏向线程 ID、偏向时间戳、对象分代年龄 | 01     | 可偏向             |

在代码进入同步块的时候，如果此同步对象没有被锁定（锁标志位为“ 01 ”状态），虚拟机首先将在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储锁对象目前的 Mark Word 的拷贝（官方把这份拷贝加了一个 Displaced 前缀，即 Displaced Mark Word），这时候线程堆栈与对象头的状态如下图所示：

![](http://oqag5mdvp.bkt.clouddn.com/201804241402_764.png)

然后，虚拟机将使用 CAS 操作尝试将对象的 Mark Word 更新为指向 Lock Record 的指针。如果这个更新动作成功了，那么这个线程就拥有了该对象的锁，并且对象 Mark Word 的锁标志位（Mark Word 的最后 2bit）将转变为“ 00 ”，即表示此对象处于轻量级锁定状态，如下图所示：

![](http://oqag5mdvp.bkt.clouddn.com/201804241403_868.png)

如果更新操作失败了，虚拟机会检查对象的 Mark Word 是否指向当前进程的栈帧，如果指向说明当前线程已经拥有了这个对象的锁，那就可以直接进入同步块继续执行，否则说明这个锁对象已经被其他线程抢占了。

如果有两条以上的线程争用同一个锁，那轻量级锁就不再有效，要膨胀为重量级锁，锁标志的状态值变为“ 10 ”，Mark Word 中存储的就是指向重量级锁（互斥量）的指针，后面等待锁的线程也要进入阻塞状态。

#### 5.5 偏向锁

偏向锁同样是 JDK1.6 引入的一项锁优化，它的目的是消除数据在无竞争情况下的同步原语。偏向锁会偏向于第一个获得它的进程，如果在接下来的执行过程中，该锁没有被其他的进程获取，则持有锁的进程将永远不需要再进行同步。