# 类加载机制

### 1. 类加载的时机

类从被加载到虚拟机内存开始，到卸载出内存为止，它的整个生命周期包括：加载（loading）、验证（verification）、准备（preparation）、解析（resolution）、初始化（initialization）、使用（using）和卸载（unloading）7个阶段。

![](http://oqag5mdvp.bkt.clouddn.com/201804221220_632.png)

Java虚拟机规范严格规定了有且只有5中情况必须进行对类的初始化，当然加载、验证、准备需要在此之前进行：

1. 遇到new、getstatic、putstatic或者invokestatic这4条字节码指令时，如果类没有进行初始化，则需要先触发其初始化。生成这4条指令的最常见的Java代码场景是：使用new关键字实例化对象的时候、读取或设置一个类的静态字段（被final修饰、已在编译期把结果放入常量池的静态字段除外）的时候，以及调用一个类的静态方法的时候。
2. 使用java.lang.reflect包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化。
3. 当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。
4. 当虚拟机启动时，用户需要指定一个要执行的主类（包含main（）方法的那个类），虚拟机会先初始化这个主类。
5. 当使用JDK 1.7的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化。

这5种场景中的行为称为对类进行主动引用。除此之外，被动引用的方式不会触发初始化。

**被动引用**

1. 通过子类引用父类的静态字段，不会导致子类初始化，只会导致父类初始化。
2. 通过数组定义来引用类，不会触发该类的初始化
3. 引用类的常量不会触发该类的初始化

### 2. 类加载过程

#### 2.1 加载

“加载”是“类加载”（Class Loading）过程的一个阶段。在加载阶段，虚拟机需要完成以下3件事情：

1. 通过一个类的全限定名来获取定义此类的二进制字节流
2. 将这个字节流所代表的静态存出结构转化为方法区的运行时数据结构
3. 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问接口

#### 2.2 验证

验证是连接阶段的第一步，这阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。

从整体上看，验证阶段大概会完成以下四个阶段的检验动作：

**1. 文件格式验证**

这一阶段验证字节流是否符合Class文件的规范，并且能被当前虚拟机处理。可能包括以下这些验证点：

- 是否以魔数0xCAFEBABE开头。
- 主、次版本号是否在当前虚拟机处理范围之内。
- 常量池的常量中是否有不被支持的常量类型（检查常量tag标志）。
- 指向常量的各种索引值中是否有指向不存在的常量或不符合类型的常量。
- ……

**2. 元数据验证**

第二阶段是对字节码描述的信息进行语义分析，以保证其描述的信息符合Java语言规范的要求。这个阶段可能包括的验证点如下：

- 这个类是否有父类（除了java.lang.Object之外，所有的类都应当有父类）。
- 这个类的父类是否继承了不允许被继承的类（被final修饰的类）。
- 如果这个类不是抽象类，是否实现了其父类或接口之中要求实现的所有方法。
- 类中的字段、方法是否与父类产生矛盾（例如覆盖了父类的final字段，或者出现不符合规则的方法重载，例如方法参数都一致，但返回值类型却不同等）。
- ……

**3. 字节码验证**

**4. 符号引用验证**

#### 2. 3. 准备

准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些变量所使用的内存都将在方法区进行分配。需要注意的是这里只包含类变量的分配，即被static修饰的变量。对于实例变量，将在对象实例化时随着对象一起分配在Java堆中。其次，初始值通常情况下是数据类型的零值。

```java
public static int value = 123;
```

那么变量value在准备阶段过后的初始值为0而不是123。如果value被final修饰，则又另当别论。被final修饰的变量在准备阶段就会被初始化为需要的值。

#### 2.4 解析

#### 2.5 初始化

### 3. 类加载器

虚拟机设计团队把类加载阶段中的“通过一个类的全限定名来获取描述此类的二进制字节流”这个动作放到Java虚拟机外部去实现，以便让应用程序自己决定如何去获取所需要的类。实现这个动作的代码模块称为“类加载器”。

#### 3.1 类的相等性与类加载器

比较两个类是否相等，只有在这两个类是由同一个类加载器加载的前提下才有意义，否则即使这两个类来自于同一个class文件，被同一个虚拟机加载，只要加载它们的类加载器不同，那这两个类就必定不相等。

#### 3.2 双亲委派模型

从Java虚拟机的角度来讲，只存在两种不同的类加载器：一种是启动类加载器（Bootstrap ClassLoader），这个类加载器使用C++语言实现（限于HotSpot虚拟机），是虚拟机自身的一部分；另一种就是所有其他的类加载器，这些类加载器都由Java语言实现，独立于虚拟机外部，并且全都继承自抽象类java.lang.ClassLoader。

而对于Java开发人员而言，类加载器可以分为以下三类：

- 启动类加载器（Bootstrap ClassLoader）：负责将存放在JAVA_HOME\lib目录中的，并且是虚拟机识别的类库加载到虚拟机内存中。启动类加载器无法被Java程序识别。
- 扩展类加载器（Extension ClassLoader）：负责加载JAVA_HOME\lib\ext目录下的所有类库，开发者可以直接使用扩展类加载器
- 应用程序类加载器：也成为系统类加载器，如果没有自定义类加载器，这个加载器是应用程序中默认的加载器

如下图所示，除了顶层的启动类加载器外，其余的类加载器都必须有自己的父类加载器，这种模型被称为**双亲委派模型**（Parents Delegation Model）。

![](http://oqag5mdvp.bkt.clouddn.com/201804221438_216.png)

双亲委派模型的工作过程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，因此所有的加载请求最终都应该传送到顶层的启动类加载器中。只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去加载。