# OOP：继承、接口和域

1. 继承关键字：extends，所有类都默认继承自Object类
2. 接口：interface
3. Java不允许多继承，但允许实现多个接口
4. 将类设置成final可以防止被继承
5. 关键字`instanceof`可以检验某对象是否为某种指定的类型

### 1. 域和可访问性

- 默认：没有任何权限修饰符的方法都是默认级别的，即同一个包内的类可以访问
- public：公开属性，任何类均可访问
- protect：保护方法，子类可访问
- private：私有方法，只有类自身可以访问

### 2. 构造器

- 如果子类没有构造器，编译器会隐式添加一个无参构造器

- 实例化子类时，编译器会先调用父类的构造器，即子类实例化时，所有的父类都会实例化

- 调用父类构造器：使用关键字`super`可以显示调用父类的构造器，但`super`必须是构造器中的第一条语句。如：`super(argus)`。

- `super`表示的是当前对象的直接超类的一个实例。所以利用`super`还可以调用父类的方法。

  `System.out.println(super.toString())`。调用父类中的方法不需要写在第一行

### 3. 类型转换

```java
Child child = new Chile();
Parent parent = child();       // 向上转换，父类引用指向子类

Child child = (Child) parent;   // 向下转换，只有父类引用指向子类时可用，否则报错
```
### 4. 接口

接口不是类，而是对类的一组需求描述，为这一组类定下需要遵循的统一格式。

#### 4.1 声明接口变量

由于接口并不是类，所以接口是无法用new运算符实例化一个对象的。但却可以声明接口的变量：

```java
Comparable x;
```

接口变量必须引用实现了接口的类对象：

```java
x = new SomeClassThatImplementsComparable();
```

接下来就可以用instanceof检查一个对象是否实现了某个接口：

```java
if (someObject instanceof Comparable) {……}
```

#### 4.2 接口中的方法

接口中的方法自动的属于public，而实现接口时的方法可见域不能小于接口中定义的方法，所以实现接口的方法也一定是public的。

在Java SE8以前， 接口中是不能实现方法的，只能提供声明。Java SE 8新增了接口中可以实现简单地方法。当然，接口中的方法不能引用实例域——接口没有实例。

**默认方法**

可以为接口方法提供一个默认实现，使用default修饰符标记：

```java
public interface Comparable<T> {
    default int compareTo(T other) { return 0; }
}
```

默认方法的作用由两个：一个是为不需要重写的方法提供默认实现，免去程序员每次重写的麻烦；二是“接口演化（interface evolution）”，将接口的新增方法提供默认实现可以保证旧的实现了该接口的方法可以正常编译、使用。

**默认方法冲突**

如果一个接口中将一个方法定义为默认方法，另一个超类或者另一个接口中也定义了同样的方法，Java怎么处理这种冲突呢？

1. **超类优先**。如果超类提供了具体方法，同样的默认方法会被忽略
2. **接口冲突**。两个接口冲突的情况下，实现接口的类必须覆盖这个冲突的方法。

