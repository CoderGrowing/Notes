# HashMap 实现原理

Java 为映射关系定义了一个 java.util.Map 接口，它的常用实现类有四个，分别为：HashMap、HashTable、LinkedHashMap 和 TreeMap。

继承关系如下：

![](http://oqag5mdvp.bkt.clouddn.com/201804121001_445.jpg)

HashMap 根据键的哈希值（hashCode）来存储数据，访问速度高，但无法按照顺序遍历。HashMap 允许键值为空和记录为空，非线程安全。

LinkedHashMap 是 HashMap 的一个子类，保存了记录的插入顺序，在用 Iterator 遍历 LinkedHashMap 时，先得到的记录肯定是先插入的，也可以在构造时带参数，按照访问次序排序。

### 存储结构

HashMap 是数组 + 链表 + 红黑树（JDK1.8 新增）实现的哈希表结构，如下如所示：

![](http://oqag5mdvp.bkt.clouddn.com/201804121006_86.jpg)

```java
map.put(key, value)
```

执行代码时，Java 会调用 key 的 hashCode 方法，计算哈希值，而后通过 Hash 算法的后两步运算（高位运算和取模运算）来定位该键值对在数组中的存储位置。而后遍历该位置上的链表，即可得到所要的值。

key 的哈希值有可能相同，造成 Hash 碰撞。避免 Hash 碰撞的方法主要有两种：采用更好的哈希函数（根据数据计算哈希值的函数）和更大的哈希数组。

当然，数组过大时会造成空间的浪费，因此在效率和空间上需要做一个权衡。Java 采用了扩容机制来权衡数组大小。具体而言，每个哈希数组有一个上限大小和一个负载因子，当数据达到上限* 负载因子后，数组大小翻倍。

默认数组大小为 16，负载因子为 0.75。

需要注意的是，哈希表的大小一定为 2 的整数次方。所以当调用 `new HashMap<>(19)` 时，哈希表的大小为 32。

### 解决冲突

哈希表为解决 Hash 冲突，可以采用**开放地址法**和**链地址法**来解决问题。HashMap 采用了链地址法。链地址法，简单来说，就是数组加链表的结合。在每个数组元素上都一个链表结构，当数据被 Hash 后，得到数组下标，把数据放在对应下标元素的链表上。

### 实现

#### 1. 确定数组中的位置

不管增加、删除、查找键值对，定位到哈希数组的位置都是很关键的第一步。我们希望哈希值尽可能少的冲突，最好是数组中的每个位置只有一个元素，这样就可以直接定位，而不用去遍历链表。为了达到这个目的，一个好的定位方法是必须的。

Java 中 Hash 算法本质上就是三步：**取 key 的 hashCode 值、高位运算、取模运算**。

```java
static final int hash(Object key) {   //jdk1.8 & jdk1.7
     int h;
     // h = key.hashCode() 为第一步 取 hashCode 值
     // h ^ (h >>> 16)  为第二步 高位参与运算
     return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
}
```

首先，`key.hashCode()` 方法返回 key 的散列值（int 类型）。如果直接拿散列值作为下标访问话，范围从 -2147483648 到 2147483648，这么大的数组当然不能直接拿来使用。Java 是将它进行取模运算后当做数组下标使用的。模运算是在 `indexFor(hash, length)` 函数中完成的：

```java
// 第三步，取模运算，利用与运算来实现，效率比 % 高
static int indexFor(int h, int length) {
    return h & (length - 1);
}
```

这也正好解释了为什么 HashMap 的数组长度要取 2 的整次幂。因为这样（数组长度 -1）正好相当于一个“**低位掩码”。**与操作的结果就是散列值的高位全部归零，只保留低位值，用来做数组下标访问。

例如长度为 16 时，16-1 = 15，位表示为：00000000 00000000 00001111，与散列值做与运算后，只保留了低位的值。但是这样又会造成问题，要是只取最后几位的话，碰撞会很严重。在这里，**高位运算**就起了作用：

```java
h = key.hashCode() ^ (h >>> 16);
```

右位移 16 位，正好是 32bit 的一半，自己的高半区和低半区做异或，就是为了**混合原始哈希码的高位和低位，以此来加大低位的随机性**。而且混合后的低位掺杂了高位的部分特征，这样高位的信息也被变相保留下来。

整个过程如下图所示：

![](http://oqag5mdvp.bkt.clouddn.com/201804121205_64.jpg)

#### 2. put 方法

put 方法的实现大概可以总结为四步：计算索引（上述所讲的内容）、扩容（当大小达到上限*负载因子的时候）、链表（当出现相同哈希值的时候）、红黑树（JDK1.8 引入，当链表长度大于 8 的时候）。

### 多线程中 HashMap 会碰到的问题

