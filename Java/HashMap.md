# HashMap实现原理

Java为映射关系定义了一个java.util.Map接口，它的常用实现类有四个，分别为：HashMap、HashTable、LinkedHashMap和TreeMap。

继承关系如下：

![](http://oqag5mdvp.bkt.clouddn.com/201804121001_445.jpg)

HashMap根据键的哈希值（hashCode）来存储数据，访问速度高，但无法按照顺序遍历。HashMap允许键值为空和记录为空，非线程安全。

LinkedHashMap是HashMap的一个子类，保存了记录的插入顺序，在用Iterator遍历LinkedHashMap时，先得到的记录肯定是先插入的，也可以在构造时带参数，按照访问次序排序。

### 存储结构

HashMap是数组+链表+红黑树（JDK1.8新增）实现的哈希表结构，如下如所示：

![](http://oqag5mdvp.bkt.clouddn.com/201804121006_86.jpg)

```java
map.put(key, value)
```

执行代码时，Java会调用key的hashCode方法，计算哈希值，而后通过Hash算法的后两步运算（高位运算和取模运算）来定位该键值对在数组中的存储位置。而后遍历该位置上的链表，即可得到所要的值。

key的哈希值有可能相同，造成Hash碰撞。避免Hash碰撞的方法主要有两种：采用更好的哈希函数（根据数据计算哈希值的函数）和更大的哈希数组。

当然，数组过大时会造成空间的浪费，因此在效率和空间上需要做一个权衡。Java采用了扩容机制来权衡数组大小。具体而言，每个哈希数组有一个上限大小和一个负载因子，当数据达到上限* 负载因子后，数组大小翻倍。

默认数组大小为16，负载因子为0.75。

需要注意的是，哈希表的大小一定为2的整数次方。所以当调用`new HashMap<>(19)`时，哈希表的大小为32。

### 解决冲突

哈希表为解决Hash冲突，可以采用**开放地址法**和**链地址法**来解决问题。HashMap采用了链地址法。链地址法，简单来说，就是数组加链表的结合。在每个数组元素上都一个链表结构，当数据被Hash后，得到数组下标，把数据放在对应下标元素的链表上。

### 实现

#### 1. 确定数组中的位置

不管增加、删除、查找键值对，定位到哈希数组的位置都是很关键的第一步。我们希望哈希值尽可能少的冲突，最好是数组中的每个位置只有一个元素，这样就可以直接定位，而不用去遍历链表。为了达到这个目的，一个好的定位方法是必须的。

Java中Hash算法本质上就是三步：**取key的hashCode值、高位运算、取模运算**。

```java
static final int hash(Object key) {   //jdk1.8 & jdk1.7
     int h;
     // h = key.hashCode() 为第一步 取hashCode值
     // h ^ (h >>> 16)  为第二步 高位参与运算
     return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
}
```

首先，`key.hashCode()`方法返回key的散列值（int类型）。如果直接拿散列值作为下标访问话，范围从-2147483648到2147483648，这么大的数组当然不能直接拿来使用。Java是将它进行取模运算后当做数组下标使用的。模运算是在`indexFor(hash, length)`函数中完成的：

```java
// 第三步，取模运算，利用与运算来实现，效率比%高
static int indexFor(int h, int length) {
    return h & (length - 1);
}
```

这也正好解释了为什么HashMap的数组长度要取2的整次幂。因为这样（数组长度-1）正好相当于一个“**低位掩码”。**与”操作的结果就是散列值的高位全部归零，只保留低位值，用来做数组下标访问。

例如长度为16时，16-1 = 15，位表示为：00000000 00000000 00001111，与散列值做与运算后，只保留了低位的值。但是这样又会造成问题，要是只取最后几位的话，碰撞会很严重。在这里，**高位运算**就起了作用：

```java
h = key.hashCode() ^ (h >>> 16);
```

右位移16位，正好是32bit的一半，自己的高半区和低半区做异或，就是为了**混合原始哈希码的高位和低位，以此来加大低位的随机性**。而且混合后的低位掺杂了高位的部分特征，这样高位的信息也被变相保留下来。

整个过程如下图所示：

![](http://oqag5mdvp.bkt.clouddn.com/201804121205_64.jpg)

#### 2. put方法

put方法的实现大概可以总结为四步：计算索引（上述所讲的内容）、扩容（当大小达到上限*负载因子的时候）、链表（当出现相同哈希值的时候）、红黑树（JDK1.8引入，当链表长度大于8的时候）。

### 多线程中HashMap会碰到的问题

