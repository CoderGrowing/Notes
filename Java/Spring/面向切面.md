# 面向切面

#### 1. 切点表达式

- **arg()**：限制连接点匹配参数为指定类型的执行方法
- **@args()**：限制连接点匹配参数由指定注解的执行方法
- **execution()**：用于匹配是连接点的执行方法
- **this()**：限制连接点匹配 AOP 代理的 bean 引用为指定类型的类
- **target**：限制连接点匹配目标对象为指定类型的类
- **@target()**：限制连接点匹配特定的执行对象，这些对象对应的类要具有指定类型的注解

#### 2. 编写切点

假设这样一个场景：正在开一场音乐会，开始前人们要关闭手机，保持安静；而后演出进行，观众鼓掌；若演出砸了，观众要求退票。首先定义一个表演接口：

```java
public interface Performance {
    public void perform();
}
```

从演出的角度来看，观众很重要。但对于演出本身的功能而言，它并不是核心。它是一个独立的关注点，因此，观众作为一个切面。

```java
@Aspect         // 声明切面
public class Audience {

    // 声明切点，execution 是切点表达式
    @Before("execution(* concert.Perfermance.perform(..))")  
    public void silenceCellPhones() {
        System.out.println("Silencing cell phone");   // perform 执行前执行此方法
    }

    @Before("execution(* concert.Perfermance.perform(..))")
    public void takeSeats() {
        System.out.println("Taking seats");
    }

    @AfterReturning("execution(* concert.Perfermance.perform(..))")
    public void applause() {
        System.out.println("CLAP CLAP CLAP!!!");
    }

    @AfterThrowing
    public void demandRefund() {
        System.out.println("Demanding a refund");
    }
}
```

切点表达式有大量重复，我们可以利用 @Pointcut 注解来解决这个问题：

```java
@Aspect
public class Audience {

    @Pointcut("execution(* concert.Perfermance.perform(..))")
    public void performance() {}

    @Before("performance()")
    public void silenceCellPhones() {
        System.out.println("Silencing cell phone");
    }

    @Before("performance()")
    public void takeSeats() {
        System.out.println("Taking seats");
    }

    @AfterReturning("performance()")
    public void applause() {
        System.out.println("CLAP CLAP CLAP!!!");
    }

    @AfterThrowing("performance()")
    public void demandRefund() {
        System.out.println("Demanding a refund");
    }
}
```

#### 3. 启用自动切面代理

如果我们只是在普通的 POJO 上加了 @Aspect 注解的话，它仍就只会是一个普通的 bean，不会被视为切面。为了让 spring 启用这个切面，需要进行自动代理配置：

```java
@Configuration
@EnableAspectJAutoProxy			// 启用自动代理
@ComponentScan
public class ConcertConfig {

    @Bean
    public Audience audience() {
        return new Audience();
    }
}
```

使用 XML 方式：

```xml
<aop:aspectj-autoproxy />
```

#### 5. 环绕通知

环绕通知是最为强大的通知类型，它能够将被通知的目标方法完全包装起来，相当于同时编写前置通知和后置通知。

```java
@Aspect
public class Audience {
    @Pointcut("execution(* concert.Perfermance.perform(..))")
    public void performance() {}
    
    @Around("performance()")    // 创建环绕通知
    public void watchPerformance(ProceedingJoinPoint jp) {
        try {
            System.out.println("Silencing cell phones");
            System.out.println("Taking seats");
            jp.proceed();
            System.out.println("CLAP CLAP CLAP!!!");
        } catch (Throwable e) {
            System.out.println("Demanding a refund");
        }
    }
}
```

#### 6. 通知中的参数

```java
@Pointcut (
	"execution (* soundsystem.CompactDisc.playTrack(int))" + "&& args(trackNumber)"
)
```

#### 7. 引入新的功能

#### 8. 通过 XML 配置切面

| AOP 配置元素               | 用途                                                 |
| ------------------------- | ---------------------------------------------------- |
| `<aop:advisor>`           | 定义 AOP 通知                                          |
| `<aop:after>`             | 定义 AOP 后置通知（不管执行是否成功）                  |
| `<aop:after-returning>`   | 定义 AOP 返回通知                                      |
| `<aop:after-throwing>`    | 定义 AOP 异常通知                                      |
| `<aop:around>`            | 定义 AOP 环绕通知                                      |
| `<aop:aspect>`            | 定义一个切面                                         |
| `<aop:aspectj-autoproxy>` | 启用 @AspectJ 注解驱动的切面                           |
| `<aop:before>`            | 定义一个 AOP 前置通知                                  |
| `<aop:config>`            | 顶层的 AOP 配置元素，大多数的 `<aop:*>` 元素必须包含在内 |
| `<aop:declare-parents>`   | 以透明的方式为被通知的对象引入额外的接口             |
| `<aop:pointcut>`          | 定义一个切点                                         |

