## 泛型

- 泛型可以使我们在编译时而不是在运行时检测出错误
- 泛型类型必须是引用类型，不能使用int、double这样的基本类型，但在泛型类型中添加元素时，基本类型会自动装箱，不会出现错误
- 泛型可以有多个参数，形式如下：`<E1, E2, E3>`
- 泛型类型的构造方法不用表示为泛型，即`public GenericStack<E>()`是错误的

### 1. 定义泛型类

我们可以为类或者接口定义泛型。

```java
public class GenericStack<E> {
    private java.util.ArrayList<E> list = new java.util.ArrayList<>();

    public int getSize() {
        return list.size();
    }

    public E peek() {
        return list.get(getSize() - 1);       // 返回最后一个元素
    }

    public void push(E o) {
        list.add(o);
    }

    // 移除并返回最后一个元素
    public E pop() {
        E o = list.get(getSize() - 1);
        list.remove(getSize() - 1);
        return o;
    }

    public boolean isEmpty() {
        return list.isEmpty();
    }

    @Override
    public String toString() {
        return "stack: " + list.toString();
    }    
}
```

### 2. 定义泛型方法

```java
public class GenericMethodDemo {
    public static void main(String[] args) {
        Integer[] integers = {1, 2, 3, 4, 5};
        String[] strings = {"London", "Paris", "New York"};

        GenericMethodDemo.<Integer>print(integers);
        GenericMethodDemo.<String>print(strings);
    }

    // 定义泛型方法
    public static <E> void print(E[] list) {
        for (int i = 0; i < list.length; i++) {
            System.out.print(list[i] + " ");
        }
        System.out.println();
    }
}
```

实例代码中我们调用泛型方法时传入了实际类型，其实简单调用`pring(integers)`或者`print(strings)`也可以，编译器会自动发现类型。

需要注意的是，当我们定义泛型类时，泛型类型是放在类名之后的，如`GenericStack<E>`，而当我们定义泛型方法时，泛型类型是放在方法返回类型之前的，如`<E> void print (E[] list)`

### 3. 几种泛型类型

**受限泛型类型**

```java
public static <E extends SomeClass> boolean equal(E obj1, E obj2) {
    return obj1.getArea() == obj2.getArea();
}
```

如上述代码所示，泛型类型被指定为了另一种类型的子类型，这种的泛型被称为受限泛型(bound)。

**原始类型**

定义泛型后可以不指定具体类型，例如：

```java
GenericStack stack = new GenericStack();
// 大致等价于
GenericStack<Object> stack = new GenericStack<Object>();
```

这样不指定具体类型的泛型被称为原始类型(raw type)。它是不安全的，不推荐使用。

**通配泛型**

```java
package Generic;

public class WildCardNeed {
    public static void main(String[] args) {
        GenericStack<Integer> intStack = new GenericStack<>();
        intStack.push(1);
        intStack.push(2);
        System.out.println("The max number is: " + max(intStack));
    }

    public static double max(GenericStack<Number> stack) {
        double max = stack.pop().doubleValue();

        while (!stack.isEmpty()) {
            double value = stack.pop().doubleValue();
            if (value > max) 
                max = value;
        }
        return max;
    }
}
```

如上述代码所展示的那样，第8行代码会出现编译错误。尽管Integer是Number的子类型，但`GenericStack<Integer>`并不是`GenericStack<Number>`的子类型。

为了避免这个问题，可以使用通配泛型类型。通配泛型类型有三种形式：`?`、`? extend T`或者`?super T`，其中T是泛型类型。

第一种的`?`被称为**非受限通配（unbounded wildcard）**，第二种形式`? extends T`被称为**受限通配（bounded wildcard）**，表示T或者T的一个子类型。第三种形式`? super T`被称为**下限通配（lower-bounded wildcard）**，表示T或者T的一个父类型。

了解了这个，上述例子只需要修改一行代码就可以解决错误

```java
// line 11
public static double max(GenericStack<? extends Number> stack)
```

### 4. 类型消除

泛型是利用一种叫做类型消除（type erasure）的技术来实现的。在编译时编译器检查泛型有没有被正确使用，一旦确认安全后，泛型会被转化为原始类型。

```java
ArrayList<String> list = new ArrayList<>();
list.add("test");
String state = list.get(0);

// 类型消除
ArrayList list = new ArrayList<>();
list.add("test");
String state = (String) list.get(0);
```

需要注意的是，不管具体的类型是什么，泛型类是被所有实例所共享的。如：

```java
ArrayList<String> list1 = new ArrayList<>();
ArrayList<Integer> list2 = new ArrayList<>();
```

尽管在编译时是两种类型，但加载到JVM中时只有一个ArrayList类会被加载，在运行时使用`ArrayList<String>`类毫无意义。由此，泛型的使用有一些限制：

- 不能使用`new T()`，即`T obj = new T()`是错误的，数组同理
- 在静态上下文中不允许类的参数是泛型类型
- 异常类不能是泛型的



