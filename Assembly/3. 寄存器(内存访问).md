# 3. 寄存器(内存访问)

## 3.1 字的存储

CPU中一个寄存器可以存放一个字单元，高8位存储高位字节，低8位存储低位字节。而在内存中，由于内存单元是字节单元，一个字需要用两个连续的地址来存放。

由此得到**字单元**的概念：存放一个字型数据(16位) 的内存单元，由两个地址连续的内存单元组成。

## 3.2 DS和[adress]

我们已经知道，CS：IP指向地址就是CPU要执行的命令。而在CPU中，**数据和程序是没有区别存储的**。那么，CPU如何分辨数据和程序呢？答案是靠**寄存器的指向地址**。CS：IP所指向的地址就是程序，而DS中存储的，就是数据在内存中的段地址，所以DS被称为**段寄存器**。当移动数据而不指定段地址时，CPU默认从DS寄存器中读取数据作为段地址。

如下面的例子，读取10000H单元的内容到AL寄存器中：

```assembly
mov ax, 1
mov ds, ax    ;将ds设为1
mov bx, [0]   ;将指定内存地址的值存入bx中，段地址为ds的值，即为1，偏移地址为0
```

这里出现了一种mov的新用法，即将内存单元中的数据直接读到寄存器中。"[...]"中的数据表示一个内存单元。

可是，我们为什么不直接将1000H送入到DS寄存器中呢？直接用`mov ds, 1000H`不就行了？问题在于8086CPU并不支持将数据直接送入段寄存器的操作，我们只能用一个寄存器作为中转。

## 3.3 字与字节的传送

当操作对象为16为寄存器时，每次进行操作的单位是字单元，操作对象为8为寄存器时，操作单位为字节。

## 3.4 栈

栈是一种常见的数据结构，它是一种LIFO(后进先出)的数据结构。对栈的操作有两条汇编语句：`push`和`pop`。`push`将元素入栈，`pop`将元素出栈。如下图所示：

![](http://oqag5mdvp.bkt.clouddn.com/201801221906_990.jpg)

需要注意的是，**栈的进出操作的操作单位都是字。**

另外，CPU如何确定哪段空间是栈空间呢？前边我们说了，CPU中对数据和程序的存储都是一样的，只是靠不同寄存器的指向来确定一段字节是数据还是程序，确定栈空间的方法也是如此。 **任意时刻，SS：SP寄存器指向栈顶元素。**

SS:SP指向的是栈空间最高地址单元的下一个单元。

还需要注意的是，栈空间已满的情况下，再进行入栈操作，会覆盖外边的数据。